<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" xmlns:lit="http://www.sdml.info/srcML/literal" xmlns:op="http://www.sdml.info/srcML/operator" xmlns:type="http://www.sdml.info/srcML/modifier" xmlns:pos="http://www.sdml.info/srcML/position" language="C++" filename="C:\School\Grad School (Comp Sci)\CSCI 685 (Software Engneering)\CodeAnalysisToolkit\projects\npp_6.2.3\scintilla\lexlib\OptionSet.h" pos:tabs="8"><comment type="line" pos:line="1" pos:column="1">// Scintilla source code edit control</comment>
<comment type="block" format="doxygen" pos:line="2" pos:column="1">/** @file OptionSet.h
 ** Manage descriptive information about an options struct for a lexer.
 ** Hold the names, positions, and descriptions of boolean, integer and string options and
 ** allow setting options and retrieving metadata about the options.
 **/</comment>
<comment type="line" pos:line="7" pos:column="1">// Copyright 2010 by Neil Hodgson &lt;neilh@scintilla.org&gt;</comment>
<comment type="line" pos:line="8" pos:column="1">// The License.txt file describes the conditions under which this software may be distributed.</comment>

<cpp:ifndef pos:line="10" pos:column="1">#<cpp:directive pos:line="10" pos:column="2">ifndef</cpp:directive> <name pos:line="10" pos:column="9">OPTIONSET_H</name></cpp:ifndef>
<cpp:define pos:line="11" pos:column="1">#<cpp:directive pos:line="11" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="11" pos:column="9">OPTIONSET_H</name></cpp:macro></cpp:define>

<cpp:ifdef pos:line="13" pos:column="1">#<cpp:directive pos:line="13" pos:column="2">ifdef</cpp:directive> <name pos:line="13" pos:column="8">SCI_NAMESPACE</name></cpp:ifdef>
<namespace pos:line="14" pos:column="1">namespace <name pos:line="14" pos:column="11">Scintilla</name> <block pos:line="14" pos:column="21">{
<cpp:endif pos:line="15" pos:column="1">#<cpp:directive pos:line="15" pos:column="2">endif</cpp:directive></cpp:endif>

<template pos:line="17" pos:column="1">template <parameter_list pos:line="17" pos:column="10">&lt;<param><type><typename pos:line="17" pos:column="11">typename</typename></type> <name pos:line="17" pos:column="20">T</name></param>&gt;</parameter_list>
<class pos:line="18" pos:column="1">class <name pos:line="18" pos:column="7">OptionSet</name> <block pos:line="18" pos:column="17">{<private type="default" pos:line="18" pos:column="18">
	<typedef pos:line="19" pos:column="9">typedef <type><name pos:line="19" pos:column="17">T</name></type> <name pos:line="19" pos:column="19">Target</name>;</typedef>
	<typedef pos:line="20" pos:column="9">typedef <type><name pos:line="20" pos:column="17">bool</name></type> <name><name pos:line="20" pos:column="22">T</name><op:operator pos:line="20" pos:column="23">::</op:operator><type:modifier pos:line="20" pos:column="25">*</type:modifier><name pos:line="20" pos:column="26">plcob</name></name>;</typedef>
	<typedef pos:line="21" pos:column="9">typedef <type><name pos:line="21" pos:column="17">int</name></type> <name><name pos:line="21" pos:column="21">T</name><op:operator pos:line="21" pos:column="22">::</op:operator><type:modifier pos:line="21" pos:column="24">*</type:modifier><name pos:line="21" pos:column="25">plcoi</name></name>;</typedef>
	<typedef pos:line="22" pos:column="9">typedef <type><name><name pos:line="22" pos:column="17">std</name><op:operator pos:line="22" pos:column="20">::</op:operator><name pos:line="22" pos:column="22">string</name></name></type> <name><name pos:line="22" pos:column="29">T</name><op:operator pos:line="22" pos:column="30">::</op:operator><type:modifier pos:line="22" pos:column="32">*</type:modifier><name pos:line="22" pos:column="33">plcos</name></name>;</typedef>
	<struct pos:line="23" pos:column="9">struct <name pos:line="23" pos:column="16">Option</name> <block pos:line="23" pos:column="23">{<public type="default" pos:line="23" pos:column="24">
		<decl_stmt><decl><type><name pos:line="24" pos:column="17">int</name></type> <name pos:line="24" pos:column="21">opType</name></decl>;</decl_stmt>
		<union pos:line="25" pos:column="17">union <block pos:line="25" pos:column="23">{<public type="default" pos:line="25" pos:column="24">
			<decl_stmt><decl><type><name pos:line="26" pos:column="25">plcob</name></type> <name pos:line="26" pos:column="31">pb</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name pos:line="27" pos:column="25">plcoi</name></type> <name pos:line="27" pos:column="31">pi</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name pos:line="28" pos:column="25">plcos</name></type> <name pos:line="28" pos:column="31">ps</name></decl>;</decl_stmt>
		</public>}</block>;</union>
		<decl_stmt><decl><type><name><name pos:line="30" pos:column="17">std</name><op:operator pos:line="30" pos:column="20">::</op:operator><name pos:line="30" pos:column="22">string</name></name></type> <name pos:line="30" pos:column="29">description</name></decl>;</decl_stmt>
		<constructor><name pos:line="31" pos:column="17">Option</name><parameter_list pos:line="31" pos:column="23">()</parameter_list> <member_list pos:line="31" pos:column="26">:
			<call><name pos:line="32" pos:column="25">opType</name><argument_list pos:line="32" pos:column="31">(<argument><expr><name pos:line="32" pos:column="32">SC_TYPE_BOOLEAN</name></expr></argument>)</argument_list></call><op:operator pos:line="32" pos:column="48">,</op:operator> <call><name pos:line="32" pos:column="50">pb</name><argument_list pos:line="32" pos:column="52">(<argument><expr><lit:literal type="number" pos:line="32" pos:column="53">0</lit:literal></expr></argument>)</argument_list></call><op:operator pos:line="32" pos:column="55">,</op:operator> <call><name pos:line="32" pos:column="57">description</name><argument_list pos:line="32" pos:column="68">(<argument><expr><lit:literal type="string" pos:line="32" pos:column="69">""</lit:literal></expr></argument>)</argument_list></call> </member_list><block pos:line="32" pos:column="73">{
		}</block></constructor>
		<constructor><name pos:line="34" pos:column="17">Option</name><parameter_list pos:line="34" pos:column="23">(<param><decl><type><name pos:line="34" pos:column="24">plcob</name></type> <name pos:line="34" pos:column="30">pb_</name></decl></param>, <param><decl><type><name><name pos:line="34" pos:column="35">std</name><op:operator pos:line="34" pos:column="38">::</op:operator><name pos:line="34" pos:column="40">string</name></name></type> <name pos:line="34" pos:column="47">description_</name><init pos:line="34" pos:column="59">=<expr><lit:literal type="string" pos:line="34" pos:column="60">""</lit:literal></expr></init></decl></param>)</parameter_list> <member_list pos:line="34" pos:column="64">:
			<call><name pos:line="35" pos:column="25">opType</name><argument_list pos:line="35" pos:column="31">(<argument><expr><name pos:line="35" pos:column="32">SC_TYPE_BOOLEAN</name></expr></argument>)</argument_list></call><op:operator pos:line="35" pos:column="48">,</op:operator> <call><name pos:line="35" pos:column="50">pb</name><argument_list pos:line="35" pos:column="52">(<argument><expr><name pos:line="35" pos:column="53">pb_</name></expr></argument>)</argument_list></call><op:operator pos:line="35" pos:column="57">,</op:operator> <call><name pos:line="35" pos:column="59">description</name><argument_list pos:line="35" pos:column="70">(<argument><expr><name pos:line="35" pos:column="71">description_</name></expr></argument>)</argument_list></call> </member_list><block pos:line="35" pos:column="85">{
		}</block></constructor>
		<constructor><name pos:line="37" pos:column="17">Option</name><parameter_list pos:line="37" pos:column="23">(<param><decl><type><name pos:line="37" pos:column="24">plcoi</name></type> <name pos:line="37" pos:column="30">pi_</name></decl></param>, <param><decl><type><name><name pos:line="37" pos:column="35">std</name><op:operator pos:line="37" pos:column="38">::</op:operator><name pos:line="37" pos:column="40">string</name></name></type> <name pos:line="37" pos:column="47">description_</name></decl></param>)</parameter_list> <member_list pos:line="37" pos:column="61">:
			<call><name pos:line="38" pos:column="25">opType</name><argument_list pos:line="38" pos:column="31">(<argument><expr><name pos:line="38" pos:column="32">SC_TYPE_INTEGER</name></expr></argument>)</argument_list></call><op:operator pos:line="38" pos:column="48">,</op:operator> <call><name pos:line="38" pos:column="50">pi</name><argument_list pos:line="38" pos:column="52">(<argument><expr><name pos:line="38" pos:column="53">pi_</name></expr></argument>)</argument_list></call><op:operator pos:line="38" pos:column="57">,</op:operator> <call><name pos:line="38" pos:column="59">description</name><argument_list pos:line="38" pos:column="70">(<argument><expr><name pos:line="38" pos:column="71">description_</name></expr></argument>)</argument_list></call> </member_list><block pos:line="38" pos:column="85">{
		}</block></constructor>
		<constructor><name pos:line="40" pos:column="17">Option</name><parameter_list pos:line="40" pos:column="23">(<param><decl><type><name pos:line="40" pos:column="24">plcos</name></type> <name pos:line="40" pos:column="30">ps_</name></decl></param>, <param><decl><type><name><name pos:line="40" pos:column="35">std</name><op:operator pos:line="40" pos:column="38">::</op:operator><name pos:line="40" pos:column="40">string</name></name></type> <name pos:line="40" pos:column="47">description_</name></decl></param>)</parameter_list> <member_list pos:line="40" pos:column="61">:
			<call><name pos:line="41" pos:column="25">opType</name><argument_list pos:line="41" pos:column="31">(<argument><expr><name pos:line="41" pos:column="32">SC_TYPE_STRING</name></expr></argument>)</argument_list></call><op:operator pos:line="41" pos:column="47">,</op:operator> <call><name pos:line="41" pos:column="49">ps</name><argument_list pos:line="41" pos:column="51">(<argument><expr><name pos:line="41" pos:column="52">ps_</name></expr></argument>)</argument_list></call><op:operator pos:line="41" pos:column="56">,</op:operator> <call><name pos:line="41" pos:column="58">description</name><argument_list pos:line="41" pos:column="69">(<argument><expr><name pos:line="41" pos:column="70">description_</name></expr></argument>)</argument_list></call> </member_list><block pos:line="41" pos:column="84">{
		}</block></constructor>
		<function><type><name pos:line="43" pos:column="17">bool</name></type> <name pos:line="43" pos:column="22">Set</name><parameter_list pos:line="43" pos:column="25">(<param><decl><type><name pos:line="43" pos:column="26">T</name> <type:modifier pos:line="43" pos:column="28">*</type:modifier></type><name pos:line="43" pos:column="29">base</name></decl></param>, <param><decl><type><specifier pos:line="43" pos:column="35">const</specifier> <name pos:line="43" pos:column="41">char</name> <type:modifier pos:line="43" pos:column="46">*</type:modifier></type><name pos:line="43" pos:column="47">val</name></decl></param>)</parameter_list> <block pos:line="43" pos:column="52">{
			<switch pos:line="44" pos:column="25">switch <condition pos:line="44" pos:column="32">(<expr><name pos:line="44" pos:column="33">opType</name></expr>)</condition> <block pos:line="44" pos:column="41">{
			<case pos:line="45" pos:column="25">case <expr><name pos:line="45" pos:column="30">SC_TYPE_BOOLEAN</name></expr>: <block pos:line="45" pos:column="47">{
					<decl_stmt><decl><type><name pos:line="46" pos:column="41">bool</name></type> <name pos:line="46" pos:column="46">option</name> <init pos:line="46" pos:column="53">= <expr><call><name pos:line="46" pos:column="55">atoi</name><argument_list pos:line="46" pos:column="59">(<argument><expr><name pos:line="46" pos:column="60">val</name></expr></argument>)</argument_list></call> <op:operator pos:line="46" pos:column="65">!=</op:operator> <lit:literal type="number" pos:line="46" pos:column="68">0</lit:literal></expr></init></decl>;</decl_stmt>
					<if pos:line="47" pos:column="41">if <condition pos:line="47" pos:column="44">(<expr><name pos:line="47" pos:column="45">(<type:modifier pos:line="47" pos:column="46">*</type:modifier><name pos:line="47" pos:column="47">base</name>)<op:operator pos:line="47" pos:column="52">.*</op:operator><name pos:line="47" pos:column="54">pb</name></name> <op:operator pos:line="47" pos:column="57">!=</op:operator> <name pos:line="47" pos:column="60">option</name></expr>)</condition><then pos:line="47" pos:column="67"> <block pos:line="47" pos:column="68">{
						<expr_stmt><expr><name pos:line="48" pos:column="49">(<type:modifier pos:line="48" pos:column="50">*</type:modifier><name pos:line="48" pos:column="51">base</name>)<op:operator pos:line="48" pos:column="56">.*</op:operator><name pos:line="48" pos:column="58">pb</name></name> <op:operator pos:line="48" pos:column="61">=</op:operator> <name pos:line="48" pos:column="63">option</name></expr>;</expr_stmt>
						<return pos:line="49" pos:column="49">return <expr><lit:literal type="boolean" pos:line="49" pos:column="56">true</lit:literal></expr>;</return>
					}</block></then></if>
					<break pos:line="51" pos:column="41">break;</break>
				}</block>
			</case><case pos:line="53" pos:column="25">case <expr><name pos:line="53" pos:column="30">SC_TYPE_INTEGER</name></expr>: <block pos:line="53" pos:column="47">{
					<decl_stmt><decl><type><name pos:line="54" pos:column="41">int</name></type> <name pos:line="54" pos:column="45">option</name> <init pos:line="54" pos:column="52">= <expr><call><name pos:line="54" pos:column="54">atoi</name><argument_list pos:line="54" pos:column="58">(<argument><expr><name pos:line="54" pos:column="59">val</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<if pos:line="55" pos:column="41">if <condition pos:line="55" pos:column="44">(<expr><name pos:line="55" pos:column="45">(<type:modifier pos:line="55" pos:column="46">*</type:modifier><name pos:line="55" pos:column="47">base</name>)<op:operator pos:line="55" pos:column="52">.*</op:operator><name pos:line="55" pos:column="54">pi</name></name> <op:operator pos:line="55" pos:column="57">!=</op:operator> <name pos:line="55" pos:column="60">option</name></expr>)</condition><then pos:line="55" pos:column="67"> <block pos:line="55" pos:column="68">{
						<expr_stmt><expr><name pos:line="56" pos:column="49">(<type:modifier pos:line="56" pos:column="50">*</type:modifier><name pos:line="56" pos:column="51">base</name>)<op:operator pos:line="56" pos:column="56">.*</op:operator><name pos:line="56" pos:column="58">pi</name></name> <op:operator pos:line="56" pos:column="61">=</op:operator> <name pos:line="56" pos:column="63">option</name></expr>;</expr_stmt>
						<return pos:line="57" pos:column="49">return <expr><lit:literal type="boolean" pos:line="57" pos:column="56">true</lit:literal></expr>;</return>
					}</block></then></if>
					<break pos:line="59" pos:column="41">break;</break>
				}</block>
			</case><case pos:line="61" pos:column="25">case <expr><name pos:line="61" pos:column="30">SC_TYPE_STRING</name></expr>: <block pos:line="61" pos:column="46">{
					<if pos:line="62" pos:column="41">if <condition pos:line="62" pos:column="44">(<expr><name pos:line="62" pos:column="45">(<type:modifier pos:line="62" pos:column="46">*</type:modifier><name pos:line="62" pos:column="47">base</name>)<op:operator pos:line="62" pos:column="52">.*</op:operator><name pos:line="62" pos:column="54">ps</name></name> <op:operator pos:line="62" pos:column="57">!=</op:operator> <name pos:line="62" pos:column="60">val</name></expr>)</condition><then pos:line="62" pos:column="64"> <block pos:line="62" pos:column="65">{
						<expr_stmt><expr><name pos:line="63" pos:column="49">(<type:modifier pos:line="63" pos:column="50">*</type:modifier><name pos:line="63" pos:column="51">base</name>)<op:operator pos:line="63" pos:column="56">.*</op:operator><name pos:line="63" pos:column="58">ps</name></name> <op:operator pos:line="63" pos:column="61">=</op:operator> <name pos:line="63" pos:column="63">val</name></expr>;</expr_stmt>
						<return pos:line="64" pos:column="49">return <expr><lit:literal type="boolean" pos:line="64" pos:column="56">true</lit:literal></expr>;</return>
					}</block></then></if>
					<break pos:line="66" pos:column="41">break;</break>
				}</block>
			</case>}</block></switch>
			<return pos:line="69" pos:column="25">return <expr><lit:literal type="boolean" pos:line="69" pos:column="32">false</lit:literal></expr>;</return>
		}</block></function>
	</public>}</block>;</struct>
	<typedef pos:line="72" pos:column="9">typedef <type><name><name pos:line="72" pos:column="17">std</name><op:operator pos:line="72" pos:column="20">::</op:operator><name><name pos:line="72" pos:column="22">map</name><argument_list pos:line="72" pos:column="25">&lt;<argument><expr><name><name pos:line="72" pos:column="26">std</name><op:operator pos:line="72" pos:column="29">::</op:operator><name pos:line="72" pos:column="31">string</name></name></expr></argument>, <argument><expr><name pos:line="72" pos:column="39">Option</name></expr></argument>&gt;</argument_list></name></name></type> <name pos:line="72" pos:column="47">OptionMap</name>;</typedef>
	<decl_stmt><decl><type><name pos:line="73" pos:column="9">OptionMap</name></type> <name pos:line="73" pos:column="19">nameToDef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name pos:line="74" pos:column="9">std</name><op:operator pos:line="74" pos:column="12">::</op:operator><name pos:line="74" pos:column="14">string</name></name></type> <name pos:line="74" pos:column="21">names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name pos:line="75" pos:column="9">std</name><op:operator pos:line="75" pos:column="12">::</op:operator><name pos:line="75" pos:column="14">string</name></name></type> <name pos:line="75" pos:column="21">wordLists</name></decl>;</decl_stmt>

	<function><type><name pos:line="77" pos:column="9">void</name></type> <name pos:line="77" pos:column="14">AppendName</name><parameter_list pos:line="77" pos:column="24">(<param><decl><type><specifier pos:line="77" pos:column="25">const</specifier> <name pos:line="77" pos:column="31">char</name> <type:modifier pos:line="77" pos:column="36">*</type:modifier></type><name pos:line="77" pos:column="37">name</name></decl></param>)</parameter_list> <block pos:line="77" pos:column="43">{
		<if pos:line="78" pos:column="17">if <condition pos:line="78" pos:column="20">(<expr><op:operator pos:line="78" pos:column="21">!</op:operator><call><name><name pos:line="78" pos:column="22">names</name><op:operator pos:line="78" pos:column="27">.</op:operator><name pos:line="78" pos:column="28">empty</name></name><argument_list pos:line="78" pos:column="33">()</argument_list></call></expr>)</condition><then pos:line="78" pos:column="36">
			<expr_stmt><expr><name pos:line="79" pos:column="25">names</name> <op:operator pos:line="79" pos:column="31">+=</op:operator> <lit:literal type="string" pos:line="79" pos:column="34">"\n"</lit:literal></expr>;</expr_stmt></then></if>
		<expr_stmt><expr><name pos:line="80" pos:column="17">names</name> <op:operator pos:line="80" pos:column="23">+=</op:operator> <name pos:line="80" pos:column="26">name</name></expr>;</expr_stmt>
	}</block></function>
</private><public pos:line="82" pos:column="1">public:
	<destructor><specifier pos:line="83" pos:column="9">virtual</specifier> <name pos:line="83" pos:column="17">~<name pos:line="83" pos:column="18">OptionSet</name></name><parameter_list pos:line="83" pos:column="27">()</parameter_list> <block pos:line="83" pos:column="30">{
	}</block></destructor>
	<function><type><name pos:line="85" pos:column="9">void</name></type> <name pos:line="85" pos:column="14">DefineProperty</name><parameter_list pos:line="85" pos:column="28">(<param><decl><type><specifier pos:line="85" pos:column="29">const</specifier> <name pos:line="85" pos:column="35">char</name> <type:modifier pos:line="85" pos:column="40">*</type:modifier></type><name pos:line="85" pos:column="41">name</name></decl></param>, <param><decl><type><name pos:line="85" pos:column="47">plcob</name></type> <name pos:line="85" pos:column="53">pb</name></decl></param>, <param><decl><type><name><name pos:line="85" pos:column="57">std</name><op:operator pos:line="85" pos:column="60">::</op:operator><name pos:line="85" pos:column="62">string</name></name></type> <name pos:line="85" pos:column="69">description</name><init pos:line="85" pos:column="80">=<expr><lit:literal type="string" pos:line="85" pos:column="81">""</lit:literal></expr></init></decl></param>)</parameter_list> <block pos:line="85" pos:column="85">{
		<expr_stmt><expr><name><name pos:line="86" pos:column="17">nameToDef</name><index pos:line="86" pos:column="26">[<expr><name pos:line="86" pos:column="27">name</name></expr>]</index></name> <op:operator pos:line="86" pos:column="33">=</op:operator> <call><name pos:line="86" pos:column="35">Option</name><argument_list pos:line="86" pos:column="41">(<argument><expr><name pos:line="86" pos:column="42">pb</name></expr></argument>, <argument><expr><name pos:line="86" pos:column="46">description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="87" pos:column="17">AppendName</name><argument_list pos:line="87" pos:column="27">(<argument><expr><name pos:line="87" pos:column="28">name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>
	<function><type><name pos:line="89" pos:column="9">void</name></type> <name pos:line="89" pos:column="14">DefineProperty</name><parameter_list pos:line="89" pos:column="28">(<param><decl><type><specifier pos:line="89" pos:column="29">const</specifier> <name pos:line="89" pos:column="35">char</name> <type:modifier pos:line="89" pos:column="40">*</type:modifier></type><name pos:line="89" pos:column="41">name</name></decl></param>, <param><decl><type><name pos:line="89" pos:column="47">plcoi</name></type> <name pos:line="89" pos:column="53">pi</name></decl></param>, <param><decl><type><name><name pos:line="89" pos:column="57">std</name><op:operator pos:line="89" pos:column="60">::</op:operator><name pos:line="89" pos:column="62">string</name></name></type> <name pos:line="89" pos:column="69">description</name><init pos:line="89" pos:column="80">=<expr><lit:literal type="string" pos:line="89" pos:column="81">""</lit:literal></expr></init></decl></param>)</parameter_list> <block pos:line="89" pos:column="85">{
		<expr_stmt><expr><name><name pos:line="90" pos:column="17">nameToDef</name><index pos:line="90" pos:column="26">[<expr><name pos:line="90" pos:column="27">name</name></expr>]</index></name> <op:operator pos:line="90" pos:column="33">=</op:operator> <call><name pos:line="90" pos:column="35">Option</name><argument_list pos:line="90" pos:column="41">(<argument><expr><name pos:line="90" pos:column="42">pi</name></expr></argument>, <argument><expr><name pos:line="90" pos:column="46">description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="91" pos:column="17">AppendName</name><argument_list pos:line="91" pos:column="27">(<argument><expr><name pos:line="91" pos:column="28">name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>
	<function><type><name pos:line="93" pos:column="9">void</name></type> <name pos:line="93" pos:column="14">DefineProperty</name><parameter_list pos:line="93" pos:column="28">(<param><decl><type><specifier pos:line="93" pos:column="29">const</specifier> <name pos:line="93" pos:column="35">char</name> <type:modifier pos:line="93" pos:column="40">*</type:modifier></type><name pos:line="93" pos:column="41">name</name></decl></param>, <param><decl><type><name pos:line="93" pos:column="47">plcos</name></type> <name pos:line="93" pos:column="53">ps</name></decl></param>, <param><decl><type><name><name pos:line="93" pos:column="57">std</name><op:operator pos:line="93" pos:column="60">::</op:operator><name pos:line="93" pos:column="62">string</name></name></type> <name pos:line="93" pos:column="69">description</name><init pos:line="93" pos:column="80">=<expr><lit:literal type="string" pos:line="93" pos:column="81">""</lit:literal></expr></init></decl></param>)</parameter_list> <block pos:line="93" pos:column="85">{
		<expr_stmt><expr><name><name pos:line="94" pos:column="17">nameToDef</name><index pos:line="94" pos:column="26">[<expr><name pos:line="94" pos:column="27">name</name></expr>]</index></name> <op:operator pos:line="94" pos:column="33">=</op:operator> <call><name pos:line="94" pos:column="35">Option</name><argument_list pos:line="94" pos:column="41">(<argument><expr><name pos:line="94" pos:column="42">ps</name></expr></argument>, <argument><expr><name pos:line="94" pos:column="46">description</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="95" pos:column="17">AppendName</name><argument_list pos:line="95" pos:column="27">(<argument><expr><name pos:line="95" pos:column="28">name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></function>
	<function><type><specifier pos:line="97" pos:column="9">const</specifier> <name pos:line="97" pos:column="15">char</name> <type:modifier pos:line="97" pos:column="20">*</type:modifier></type><name pos:line="97" pos:column="21">PropertyNames</name><parameter_list pos:line="97" pos:column="34">()</parameter_list> <block pos:line="97" pos:column="37">{
		<return pos:line="98" pos:column="17">return <expr><call><name><name pos:line="98" pos:column="24">names</name><op:operator pos:line="98" pos:column="29">.</op:operator><name pos:line="98" pos:column="30">c_str</name></name><argument_list pos:line="98" pos:column="35">()</argument_list></call></expr>;</return>
	}</block></function>
	<function><type><name pos:line="100" pos:column="9">int</name></type> <name pos:line="100" pos:column="13">PropertyType</name><parameter_list pos:line="100" pos:column="25">(<param><decl><type><specifier pos:line="100" pos:column="26">const</specifier> <name pos:line="100" pos:column="32">char</name> <type:modifier pos:line="100" pos:column="37">*</type:modifier></type><name pos:line="100" pos:column="38">name</name></decl></param>)</parameter_list> <block pos:line="100" pos:column="44">{
		<decl_stmt><decl><type><typename pos:line="101" pos:column="17">typename</typename> <name><name pos:line="101" pos:column="26">OptionMap</name><op:operator pos:line="101" pos:column="35">::</op:operator><name pos:line="101" pos:column="37">iterator</name></name></type> <name pos:line="101" pos:column="46">it</name> <init pos:line="101" pos:column="49">= <expr><call><name><name pos:line="101" pos:column="51">nameToDef</name><op:operator pos:line="101" pos:column="60">.</op:operator><name pos:line="101" pos:column="61">find</name></name><argument_list pos:line="101" pos:column="65">(<argument><expr><name pos:line="101" pos:column="66">name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if pos:line="102" pos:column="17">if <condition pos:line="102" pos:column="20">(<expr><name pos:line="102" pos:column="21">it</name> <op:operator pos:line="102" pos:column="24">!=</op:operator> <call><name><name pos:line="102" pos:column="27">nameToDef</name><op:operator pos:line="102" pos:column="36">.</op:operator><name pos:line="102" pos:column="37">end</name></name><argument_list pos:line="102" pos:column="40">()</argument_list></call></expr>)</condition><then pos:line="102" pos:column="43"> <block pos:line="102" pos:column="44">{
			<return pos:line="103" pos:column="25">return <expr><name><name pos:line="103" pos:column="32">it</name><op:operator pos:line="103" pos:column="34">-&gt;</op:operator><name pos:line="103" pos:column="36">second</name><op:operator pos:line="103" pos:column="42">.</op:operator><name pos:line="103" pos:column="43">opType</name></name></expr>;</return>
		}</block></then></if>
		<return pos:line="105" pos:column="17">return <expr><name pos:line="105" pos:column="24">SC_TYPE_BOOLEAN</name></expr>;</return>
	}</block></function>
	<function><type><specifier pos:line="107" pos:column="9">const</specifier> <name pos:line="107" pos:column="15">char</name> <type:modifier pos:line="107" pos:column="20">*</type:modifier></type><name pos:line="107" pos:column="21">DescribeProperty</name><parameter_list pos:line="107" pos:column="37">(<param><decl><type><specifier pos:line="107" pos:column="38">const</specifier> <name pos:line="107" pos:column="44">char</name> <type:modifier pos:line="107" pos:column="49">*</type:modifier></type><name pos:line="107" pos:column="50">name</name></decl></param>)</parameter_list> <block pos:line="107" pos:column="56">{
		<decl_stmt><decl><type><typename pos:line="108" pos:column="17">typename</typename> <name><name pos:line="108" pos:column="26">OptionMap</name><op:operator pos:line="108" pos:column="35">::</op:operator><name pos:line="108" pos:column="37">iterator</name></name></type> <name pos:line="108" pos:column="46">it</name> <init pos:line="108" pos:column="49">= <expr><call><name><name pos:line="108" pos:column="51">nameToDef</name><op:operator pos:line="108" pos:column="60">.</op:operator><name pos:line="108" pos:column="61">find</name></name><argument_list pos:line="108" pos:column="65">(<argument><expr><name pos:line="108" pos:column="66">name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if pos:line="109" pos:column="17">if <condition pos:line="109" pos:column="20">(<expr><name pos:line="109" pos:column="21">it</name> <op:operator pos:line="109" pos:column="24">!=</op:operator> <call><name><name pos:line="109" pos:column="27">nameToDef</name><op:operator pos:line="109" pos:column="36">.</op:operator><name pos:line="109" pos:column="37">end</name></name><argument_list pos:line="109" pos:column="40">()</argument_list></call></expr>)</condition><then pos:line="109" pos:column="43"> <block pos:line="109" pos:column="44">{
			<return pos:line="110" pos:column="25">return <expr><call><name><name pos:line="110" pos:column="32">it</name><op:operator pos:line="110" pos:column="34">-&gt;</op:operator><name pos:line="110" pos:column="36">second</name><op:operator pos:line="110" pos:column="42">.</op:operator><name pos:line="110" pos:column="43">description</name><op:operator pos:line="110" pos:column="54">.</op:operator><name pos:line="110" pos:column="55">c_str</name></name><argument_list pos:line="110" pos:column="60">()</argument_list></call></expr>;</return>
		}</block></then></if>
		<return pos:line="112" pos:column="17">return <expr><lit:literal type="string" pos:line="112" pos:column="24">""</lit:literal></expr>;</return>
	}</block></function>

	<function><type><name pos:line="115" pos:column="9">bool</name></type> <name pos:line="115" pos:column="14">PropertySet</name><parameter_list pos:line="115" pos:column="25">(<param><decl><type><name pos:line="115" pos:column="26">T</name> <type:modifier pos:line="115" pos:column="28">*</type:modifier></type><name pos:line="115" pos:column="29">base</name></decl></param>, <param><decl><type><specifier pos:line="115" pos:column="35">const</specifier> <name pos:line="115" pos:column="41">char</name> <type:modifier pos:line="115" pos:column="46">*</type:modifier></type><name pos:line="115" pos:column="47">name</name></decl></param>, <param><decl><type><specifier pos:line="115" pos:column="53">const</specifier> <name pos:line="115" pos:column="59">char</name> <type:modifier pos:line="115" pos:column="64">*</type:modifier></type><name pos:line="115" pos:column="65">val</name></decl></param>)</parameter_list> <block pos:line="115" pos:column="70">{
		<decl_stmt><decl><type><typename pos:line="116" pos:column="17">typename</typename> <name><name pos:line="116" pos:column="26">OptionMap</name><op:operator pos:line="116" pos:column="35">::</op:operator><name pos:line="116" pos:column="37">iterator</name></name></type> <name pos:line="116" pos:column="46">it</name> <init pos:line="116" pos:column="49">= <expr><call><name><name pos:line="116" pos:column="51">nameToDef</name><op:operator pos:line="116" pos:column="60">.</op:operator><name pos:line="116" pos:column="61">find</name></name><argument_list pos:line="116" pos:column="65">(<argument><expr><name pos:line="116" pos:column="66">name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if pos:line="117" pos:column="17">if <condition pos:line="117" pos:column="20">(<expr><name pos:line="117" pos:column="21">it</name> <op:operator pos:line="117" pos:column="24">!=</op:operator> <call><name><name pos:line="117" pos:column="27">nameToDef</name><op:operator pos:line="117" pos:column="36">.</op:operator><name pos:line="117" pos:column="37">end</name></name><argument_list pos:line="117" pos:column="40">()</argument_list></call></expr>)</condition><then pos:line="117" pos:column="43"> <block pos:line="117" pos:column="44">{
			<return pos:line="118" pos:column="25">return <expr><call><name><name pos:line="118" pos:column="32">it</name><op:operator pos:line="118" pos:column="34">-&gt;</op:operator><name pos:line="118" pos:column="36">second</name><op:operator pos:line="118" pos:column="42">.</op:operator><name pos:line="118" pos:column="43">Set</name></name><argument_list pos:line="118" pos:column="46">(<argument><expr><name pos:line="118" pos:column="47">base</name></expr></argument>, <argument><expr><name pos:line="118" pos:column="53">val</name></expr></argument>)</argument_list></call></expr>;</return>
		}</block></then></if>
		<return pos:line="120" pos:column="17">return <expr><lit:literal type="boolean" pos:line="120" pos:column="24">false</lit:literal></expr>;</return>
	}</block></function>

	<function><type><name pos:line="123" pos:column="9">void</name></type> <name pos:line="123" pos:column="14">DefineWordListSets</name><parameter_list pos:line="123" pos:column="32">(<param><decl><type><specifier pos:line="123" pos:column="33">const</specifier> <name pos:line="123" pos:column="39">char</name> <type:modifier pos:line="123" pos:column="44">*</type:modifier> <specifier pos:line="123" pos:column="46">const</specifier></type> <name><name pos:line="123" pos:column="52">wordListDescriptions</name><index pos:line="123" pos:column="72">[]</index></name></decl></param>)</parameter_list> <block pos:line="123" pos:column="76">{
		<if pos:line="124" pos:column="17">if <condition pos:line="124" pos:column="20">(<expr><name pos:line="124" pos:column="21">wordListDescriptions</name></expr>)</condition><then pos:line="124" pos:column="42"> <block pos:line="124" pos:column="43">{
			<for pos:line="125" pos:column="25">for (<init><decl><type><name pos:line="125" pos:column="30">size_t</name></type> <name pos:line="125" pos:column="37">wl</name> <init pos:line="125" pos:column="40">= <expr><lit:literal type="number" pos:line="125" pos:column="42">0</lit:literal></expr></init></decl>;</init> <condition><expr><name><name pos:line="125" pos:column="45">wordListDescriptions</name><index pos:line="125" pos:column="65">[<expr><name pos:line="125" pos:column="66">wl</name></expr>]</index></name></expr>;</condition> <incr><expr><name pos:line="125" pos:column="71">wl</name><op:operator pos:line="125" pos:column="73">++</op:operator></expr></incr>) <block pos:line="125" pos:column="77">{
				<if pos:line="126" pos:column="33">if <condition pos:line="126" pos:column="36">(<expr><op:operator pos:line="126" pos:column="37">!</op:operator><call><name><name pos:line="126" pos:column="38">wordLists</name><op:operator pos:line="126" pos:column="47">.</op:operator><name pos:line="126" pos:column="48">empty</name></name><argument_list pos:line="126" pos:column="53">()</argument_list></call></expr>)</condition><then pos:line="126" pos:column="56">
					<expr_stmt><expr><name pos:line="127" pos:column="41">wordLists</name> <op:operator pos:line="127" pos:column="51">+=</op:operator> <lit:literal type="string" pos:line="127" pos:column="54">"\n"</lit:literal></expr>;</expr_stmt></then></if>
				<expr_stmt><expr><name pos:line="128" pos:column="33">wordLists</name> <op:operator pos:line="128" pos:column="43">+=</op:operator> <name><name pos:line="128" pos:column="46">wordListDescriptions</name><index pos:line="128" pos:column="66">[<expr><name pos:line="128" pos:column="67">wl</name></expr>]</index></name></expr>;</expr_stmt>
			}</block></for>
		}</block></then></if>
	}</block></function>

	<function><type><specifier pos:line="133" pos:column="9">const</specifier> <name pos:line="133" pos:column="15">char</name> <type:modifier pos:line="133" pos:column="20">*</type:modifier></type><name pos:line="133" pos:column="21">DescribeWordListSets</name><parameter_list pos:line="133" pos:column="41">()</parameter_list> <block pos:line="133" pos:column="44">{
		<return pos:line="134" pos:column="17">return <expr><call><name><name pos:line="134" pos:column="24">wordLists</name><op:operator pos:line="134" pos:column="33">.</op:operator><name pos:line="134" pos:column="34">c_str</name></name><argument_list pos:line="134" pos:column="39">()</argument_list></call></expr>;</return>
	}</block></function>
</public>}</block>;</class></template>

<cpp:ifdef pos:line="138" pos:column="1">#<cpp:directive pos:line="138" pos:column="2">ifdef</cpp:directive> <name pos:line="138" pos:column="8">SCI_NAMESPACE</name></cpp:ifdef>
}</block></namespace>
<cpp:endif pos:line="140" pos:column="1">#<cpp:directive pos:line="140" pos:column="2">endif</cpp:directive></cpp:endif>

<cpp:endif pos:line="142" pos:column="1">#<cpp:directive pos:line="142" pos:column="2">endif</cpp:directive></cpp:endif>
</unit>
