<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" xmlns:lit="http://www.sdml.info/srcML/literal" xmlns:op="http://www.sdml.info/srcML/operator" xmlns:type="http://www.sdml.info/srcML/modifier" xmlns:pos="http://www.sdml.info/srcML/position" language="C++" filename="C:\School\Grad School (Comp Sci)\CSCI 685 (Software Engneering)\CodeAnalysisToolkit\projects\npp_6.2.3\scintilla\src\RESearch.cxx" pos:tabs="8"><comment type="line" pos:line="1" pos:column="1">// Scintilla source code edit control</comment>
<comment type="block" format="doxygen" pos:line="2" pos:column="1">/** @file RESearch.cxx
 ** Regular expression search library.
 **/</comment>

<comment type="block" pos:line="6" pos:column="1">/*
 * regex - Regular expression pattern matching and replacement
 *
 * By:  Ozan S. Yigit (oz)
 *      Dept. of Computer Science
 *      York University
 *
 * Original code available from http://www.cs.yorku.ca/~oz/
 * Translation to C++ by Neil Hodgson neilh@scintilla.org
 * Removed all use of register.
 * Converted to modern function prototypes.
 * Put all global/static variables into an object so this code can be
 * used from multiple threads, etc.
 * Some extensions by Philippe Lhoste PhiLho(a)GMX.net
 * '?' extensions by Michael Mullin masmullin@gmail.com
 *
 * These routines are the PUBLIC DOMAIN equivalents of regex
 * routines as found in 4.nBSD UN*X, with minor extensions.
 *
 * These routines are derived from various implementations found
 * in software tools books, and Conroy's grep. They are NOT derived
 * from licensed/restricted software.
 * For more interesting/academic/complicated implementations,
 * see Henry Spencer's regexp routines, or GNU Emacs pattern
 * matching module.
 *
 * Modification history removed.
 *
 * Interfaces:
 *  RESearch::Compile:      compile a regular expression into a NFA.
 *
 *          const char *RESearch::Compile(const char *pattern, int length,
 *                                        bool caseSensitive, bool posix)
 *
 * Returns a short error string if they fail.
 *
 *  RESearch::Execute:      execute the NFA to match a pattern.
 *
 *          int RESearch::Execute(characterIndexer &amp;ci, int lp, int endp)
 *
 *  RESearch::Substitute:   substitute the matched portions in a new string.
 *
 *          int RESearch::Substitute(CharacterIndexer &amp;ci, char *src, char *dst)
 *
 *  re_fail:                failure routine for RESearch::Execute. (no longer used)
 *
 *          void re_fail(char *msg, char op)
 *
 * Regular Expressions:
 *
 *      [1]     char    matches itself, unless it is a special
 *                      character (metachar): . \ [ ] * + ? ^ $
 *                      and ( ) if posix option.
 *
 *      [2]     .       matches any character.
 *
 *      [3]     \       matches the character following it, except:
 *                      - \a, \b, \f, \n, \r, \t, \v match the corresponding C
 *                      escape char, respectively BEL, BS, FF, LF, CR, TAB and VT;
 *                      Note that \r and \n are never matched because Scintilla
 *                      regex searches are made line per line
 *                      (stripped of end-of-line chars).
 *                      - if not in posix mode, when followed by a
 *                      left or right round bracket (see [8]);
 *                      - when followed by a digit 1 to 9 (see [9]);
 *                      - when followed by a left or right angle bracket
 *                      (see [10]);
 *                      - when followed by d, D, s, S, w or W (see [11]);
 *                      - when followed by x and two hexa digits (see [12].
 *                      Backslash is used as an escape character for all
 *                      other meta-characters, and itself.
 *
 *      [4]     [set]   matches one of the characters in the set.
 *                      If the first character in the set is "^",
 *                      it matches the characters NOT in the set, i.e.
 *                      complements the set. A shorthand S-E (start dash end)
 *                      is used to specify a set of characters S up to
 *                      E, inclusive. S and E must be characters, otherwise
 *                      the dash is taken literally (eg. in expression [\d-a]).
 *                      The special characters "]" and "-" have no special
 *                      meaning if they appear as the first chars in the set.
 *                      To include both, put - first: [-]A-Z]
 *                      (or just backslash them).
 *                      examples:        match:
 *
 *                              [-]|]    matches these 3 chars,
 *
 *                              []-|]    matches from ] to | chars
 *
 *                              [a-z]    any lowercase alpha
 *
 *                              [^-]]    any char except - and ]
 *
 *                              [^A-Z]   any char except uppercase
 *                                       alpha
 *
 *                              [a-zA-Z] any alpha
 *
 *      [5]     *       any regular expression form [1] to [4]
 *                      (except [8], [9] and [10] forms of [3]),
 *                      followed by closure char (*)
 *                      matches zero or more matches of that form.
 *
 *      [6]     +       same as [5], except it matches one or more.
 *
 *      [5-6]           Both [5] and [6] are greedy (they match as much as possible).
 *                      Unless they are followed by the 'lazy' quantifier (?)
 *                      In which case both [5] and [6] try to match as little as possible
 *
 *      [7]     ?       same as [5] except it matches zero or one.
 *
 *      [8]             a regular expression in the form [1] to [13], enclosed
 *                      as \(form\) (or (form) with posix flag) matches what
 *                      form matches. The enclosure creates a set of tags,
 *                      used for [9] and for pattern substitution.
 *                      The tagged forms are numbered starting from 1.
 *
 *      [9]             a \ followed by a digit 1 to 9 matches whatever a
 *                      previously tagged regular expression ([8]) matched.
 *
 *      [10]    \&lt;      a regular expression starting with a \&lt; construct
 *              \&gt;      and/or ending with a \&gt; construct, restricts the
 *                      pattern matching to the beginning of a word, and/or
 *                      the end of a word. A word is defined to be a character
 *                      string beginning and/or ending with the characters
 *                      A-Z a-z 0-9 and _. Scintilla extends this definition
 *                      by user setting. The word must also be preceded and/or
 *                      followed by any character outside those mentioned.
 *
 *      [11]    \l      a backslash followed by d, D, s, S, w or W,
 *                      becomes a character class (both inside and
 *                      outside sets []).
 *                        d: decimal digits
 *                        D: any char except decimal digits
 *                        s: whitespace (space, \t \n \r \f \v)
 *                        S: any char except whitespace (see above)
 *                        w: alphanumeric &amp; underscore (changed by user setting)
 *                        W: any char except alphanumeric &amp; underscore (see above)
 *
 *      [12]    \xHH    a backslash followed by x and two hexa digits,
 *                      becomes the character whose Ascii code is equal
 *                      to these digits. If not followed by two digits,
 *                      it is 'x' char itself.
 *
 *      [13]            a composite regular expression xy where x and y
 *                      are in the form [1] to [12] matches the longest
 *                      match of x followed by a match for y.
 *
 *      [14]    ^       a regular expression starting with a ^ character
 *              $       and/or ending with a $ character, restricts the
 *                      pattern matching to the beginning of the line,
 *                      or the end of line. [anchors] Elsewhere in the
 *                      pattern, ^ and $ are treated as ordinary characters.
 *
 *
 * Acknowledgements:
 *
 *  HCR's Hugh Redelmeier has been most helpful in various
 *  stages of development. He convinced me to include BOW
 *  and EOW constructs, originally invented by Rob Pike at
 *  the University of Toronto.
 *
 * References:
 *              Software tools                  Kernighan &amp; Plauger
 *              Software tools in Pascal        Kernighan &amp; Plauger
 *              Grep [rsx-11 C dist]            David Conroy
 *              ed - text editor                Un*x Programmer's Manual
 *              Advanced editing on Un*x        B. W. Kernighan
 *              RegExp routines                 Henry Spencer
 *
 * Notes:
 *
 *  This implementation uses a bit-set representation for character
 *  classes for speed and compactness. Each character is represented
 *  by one bit in a 256-bit block. Thus, CCL always takes a
 *	constant 32 bytes in the internal nfa, and RESearch::Execute does a single
 *  bit comparison to locate the character in the set.
 *
 * Examples:
 *
 *  pattern:    foo*.*
 *  compile:    CHR f CHR o CLO CHR o END CLO ANY END END
 *  matches:    fo foo fooo foobar fobar foxx ...
 *
 *  pattern:    fo[ob]a[rz]
 *  compile:    CHR f CHR o CCL bitset CHR a CCL bitset END
 *  matches:    fobar fooar fobaz fooaz
 *
 *  pattern:    foo\\+
 *  compile:    CHR f CHR o CHR o CHR \ CLO CHR \ END END
 *  matches:    foo\ foo\\ foo\\\  ...
 *
 *  pattern:    \(foo\)[1-3]\1  (same as foo[1-3]foo)
 *  compile:    BOT 1 CHR f CHR o CHR o EOT 1 CCL bitset REF 1 END
 *  matches:    foo1foo foo2foo foo3foo
 *
 *  pattern:    \(fo.*\)-\1
 *  compile:    BOT 1 CHR f CHR o CLO ANY END EOT 1 CHR - REF 1 END
 *  matches:    foo-foo fo-fo fob-fob foobar-foobar ...
 */</comment>

<cpp:include pos:line="207" pos:column="1">#<cpp:directive pos:line="207" pos:column="2">include</cpp:directive> <cpp:file pos:line="207" pos:column="10">&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include pos:line="209" pos:column="1">#<cpp:directive pos:line="209" pos:column="2">include</cpp:directive> <cpp:file><lit:literal type="string" pos:line="209" pos:column="10">"CharClassify.h"</lit:literal></cpp:file></cpp:include>
<cpp:include pos:line="210" pos:column="1">#<cpp:directive pos:line="210" pos:column="2">include</cpp:directive> <cpp:file><lit:literal type="string" pos:line="210" pos:column="10">"RESearch.h"</lit:literal></cpp:file></cpp:include>

<comment type="line" pos:line="212" pos:column="1">// Shut up annoying Visual C++ warnings:</comment>
<cpp:ifdef pos:line="213" pos:column="1">#<cpp:directive pos:line="213" pos:column="2">ifdef</cpp:directive> <name pos:line="213" pos:column="8">_MSC_VER</name></cpp:ifdef>
<cpp:pragma pos:line="214" pos:column="1">#<cpp:directive pos:line="214" pos:column="2">pragma</cpp:directive> warning(disable: 4514)</cpp:pragma>
<cpp:endif pos:line="215" pos:column="1">#<cpp:directive pos:line="215" pos:column="2">endif</cpp:directive></cpp:endif>

<cpp:ifdef pos:line="217" pos:column="1">#<cpp:directive pos:line="217" pos:column="2">ifdef</cpp:directive> <name pos:line="217" pos:column="8">SCI_NAMESPACE</name></cpp:ifdef>
<using pos:line="218" pos:column="1">using namespace <name pos:line="218" pos:column="17">Scintilla</name>;</using>
<cpp:endif pos:line="219" pos:column="1">#<cpp:directive pos:line="219" pos:column="2">endif</cpp:directive></cpp:endif>

<cpp:define pos:line="221" pos:column="1">#<cpp:directive pos:line="221" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="221" pos:column="9">OKP</name></cpp:macro>     <cpp:value pos:line="221" pos:column="17">1</cpp:value></cpp:define>
<cpp:define pos:line="222" pos:column="1">#<cpp:directive pos:line="222" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="222" pos:column="9">NOP</name></cpp:macro>     <cpp:value pos:line="222" pos:column="17">0</cpp:value></cpp:define>

<cpp:define pos:line="224" pos:column="1">#<cpp:directive pos:line="224" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="224" pos:column="9">CHR</name></cpp:macro>     <cpp:value pos:line="224" pos:column="17">1</cpp:value></cpp:define>
<cpp:define pos:line="225" pos:column="1">#<cpp:directive pos:line="225" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="225" pos:column="9">ANY</name></cpp:macro>     <cpp:value pos:line="225" pos:column="17">2</cpp:value></cpp:define>
<cpp:define pos:line="226" pos:column="1">#<cpp:directive pos:line="226" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="226" pos:column="9">CCL</name></cpp:macro>     <cpp:value pos:line="226" pos:column="17">3</cpp:value></cpp:define>
<cpp:define pos:line="227" pos:column="1">#<cpp:directive pos:line="227" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="227" pos:column="9">BOL</name></cpp:macro>     <cpp:value pos:line="227" pos:column="17">4</cpp:value></cpp:define>
<cpp:define pos:line="228" pos:column="1">#<cpp:directive pos:line="228" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="228" pos:column="9">EOL</name></cpp:macro>     <cpp:value pos:line="228" pos:column="17">5</cpp:value></cpp:define>
<cpp:define pos:line="229" pos:column="1">#<cpp:directive pos:line="229" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="229" pos:column="9">BOT</name></cpp:macro>     <cpp:value pos:line="229" pos:column="17">6</cpp:value></cpp:define>
<cpp:define pos:line="230" pos:column="1">#<cpp:directive pos:line="230" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="230" pos:column="9">EOT</name></cpp:macro>     <cpp:value pos:line="230" pos:column="17">7</cpp:value></cpp:define>
<cpp:define pos:line="231" pos:column="1">#<cpp:directive pos:line="231" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="231" pos:column="9">BOW</name></cpp:macro>     <cpp:value pos:line="231" pos:column="17">8</cpp:value></cpp:define>
<cpp:define pos:line="232" pos:column="1">#<cpp:directive pos:line="232" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="232" pos:column="9">EOW</name></cpp:macro>     <cpp:value pos:line="232" pos:column="17">9</cpp:value></cpp:define>
<cpp:define pos:line="233" pos:column="1">#<cpp:directive pos:line="233" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="233" pos:column="9">REF</name></cpp:macro>     <cpp:value pos:line="233" pos:column="17">10</cpp:value></cpp:define>
<cpp:define pos:line="234" pos:column="1">#<cpp:directive pos:line="234" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="234" pos:column="9">CLO</name></cpp:macro>     <cpp:value pos:line="234" pos:column="17">11</cpp:value></cpp:define>
<cpp:define pos:line="235" pos:column="1">#<cpp:directive pos:line="235" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="235" pos:column="9">CLQ</name></cpp:macro>     <cpp:value pos:line="235" pos:column="17">12</cpp:value></cpp:define> <comment type="block" pos:line="235" pos:column="20">/* 0 to 1 closure */</comment>
<cpp:define pos:line="236" pos:column="1">#<cpp:directive pos:line="236" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="236" pos:column="9">LCLO</name></cpp:macro>    <cpp:value pos:line="236" pos:column="17">13</cpp:value></cpp:define> <comment type="block" pos:line="236" pos:column="20">/* lazy closure */</comment>

<cpp:define pos:line="238" pos:column="1">#<cpp:directive pos:line="238" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="238" pos:column="9">END</name></cpp:macro>     <cpp:value pos:line="238" pos:column="17">0</cpp:value></cpp:define>

<comment type="block" pos:line="240" pos:column="1">/*
 * The following defines are not meant to be changeable.
 * They are for readability only.
 */</comment>
<cpp:define pos:line="244" pos:column="1">#<cpp:directive pos:line="244" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="244" pos:column="9">BLKIND</name></cpp:macro>  <cpp:value pos:line="244" pos:column="17">0370</cpp:value></cpp:define>
<cpp:define pos:line="245" pos:column="1">#<cpp:directive pos:line="245" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="245" pos:column="9">BITIND</name></cpp:macro>  <cpp:value pos:line="245" pos:column="17">07</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier pos:line="247" pos:column="1">const</specifier> <name pos:line="247" pos:column="7">char</name></type> <name><name pos:line="247" pos:column="12">bitarr</name><index pos:line="247" pos:column="18">[]</index></name> <init pos:line="247" pos:column="21">= <expr><block pos:line="247" pos:column="23">{ <expr><lit:literal type="number" pos:line="247" pos:column="25">1</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="28">2</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="31">4</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="34">8</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="37">16</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="41">32</lit:literal></expr>, <expr><lit:literal type="number" pos:line="247" pos:column="45">64</lit:literal></expr>, <expr><lit:literal type="char" pos:line="247" pos:column="49">'\200'</lit:literal></expr> }</block></expr></init></decl>;</decl_stmt>

<cpp:define pos:line="249" pos:column="1">#<cpp:directive pos:line="249" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="249" pos:column="9">badpat</name><parameter_list pos:line="249" pos:column="15">(<param><type><name pos:line="249" pos:column="16">x</name></type></param>)</parameter_list></cpp:macro>	<cpp:value pos:line="249" pos:column="25">(*nfa = END, x)</cpp:value></cpp:define>

<comment type="block" pos:line="251" pos:column="1">/*
 * Character classification table for word boundary operators BOW
 * and EOW is passed in by the creator of this object (Scintilla
 * Document). The Document default state is that word chars are:
 * 0-9, a-z, A-Z and _
 */</comment>

<constructor><name><name pos:line="258" pos:column="1">RESearch</name><op:operator pos:line="258" pos:column="9">::</op:operator><name pos:line="258" pos:column="11">RESearch</name></name><parameter_list pos:line="258" pos:column="19">(<param><decl><type><name pos:line="258" pos:column="20">CharClassify</name> <type:modifier pos:line="258" pos:column="33">*</type:modifier></type><name pos:line="258" pos:column="34">charClassTable</name></decl></param>)</parameter_list> <block pos:line="258" pos:column="50">{
	<expr_stmt><expr><name pos:line="259" pos:column="9">failure</name> <op:operator pos:line="259" pos:column="17">=</op:operator> <lit:literal type="number" pos:line="259" pos:column="19">0</lit:literal></expr>;</expr_stmt>
	<expr_stmt><expr><name pos:line="260" pos:column="9">charClass</name> <op:operator pos:line="260" pos:column="19">=</op:operator> <name pos:line="260" pos:column="21">charClassTable</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name pos:line="261" pos:column="9">Init</name><argument_list pos:line="261" pos:column="13">()</argument_list></call></expr>;</expr_stmt>
}</block></constructor>

<destructor><name><name pos:line="264" pos:column="1">RESearch</name><op:operator pos:line="264" pos:column="9">::</op:operator>~<name pos:line="264" pos:column="12">RESearch</name></name><parameter_list pos:line="264" pos:column="20">()</parameter_list> <block pos:line="264" pos:column="23">{
	<expr_stmt><expr><call><name pos:line="265" pos:column="9">Clear</name><argument_list pos:line="265" pos:column="14">()</argument_list></call></expr>;</expr_stmt>
}</block></destructor>

<function><type><name pos:line="268" pos:column="1">void</name></type> <name><name pos:line="268" pos:column="6">RESearch</name><op:operator pos:line="268" pos:column="14">::</op:operator><name pos:line="268" pos:column="16">Init</name></name><parameter_list pos:line="268" pos:column="20">()</parameter_list> <block pos:line="268" pos:column="23">{
	<expr_stmt><expr><name pos:line="269" pos:column="9">sta</name> <op:operator pos:line="269" pos:column="13">=</op:operator> <name pos:line="269" pos:column="15">NOP</name></expr>;</expr_stmt>                  <comment type="block" pos:line="269" pos:column="37">/* status of lastpat */</comment>
	<expr_stmt><expr><name pos:line="270" pos:column="9">bol</name> <op:operator pos:line="270" pos:column="13">=</op:operator> <lit:literal type="number" pos:line="270" pos:column="15">0</lit:literal></expr>;</expr_stmt>
	<for pos:line="271" pos:column="9">for (<init><decl><type><name pos:line="271" pos:column="14">int</name></type> <name pos:line="271" pos:column="18">i</name> <init pos:line="271" pos:column="20">= <expr><lit:literal type="number" pos:line="271" pos:column="22">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="271" pos:column="25">i</name> <op:operator pos:line="271" pos:column="27">&lt;</op:operator> <name pos:line="271" pos:column="29">MAXTAG</name></expr>;</condition> <incr><expr><name pos:line="271" pos:column="37">i</name><op:operator pos:line="271" pos:column="38">++</op:operator></expr></incr>)
		<expr_stmt><expr><name><name pos:line="272" pos:column="17">pat</name><index pos:line="272" pos:column="20">[<expr><name pos:line="272" pos:column="21">i</name></expr>]</index></name> <op:operator pos:line="272" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="272" pos:column="26">0</lit:literal></expr>;</expr_stmt></for>
	<for pos:line="273" pos:column="9">for (<init><decl><type><name pos:line="273" pos:column="14">int</name></type> <name pos:line="273" pos:column="18">j</name> <init pos:line="273" pos:column="20">= <expr><lit:literal type="number" pos:line="273" pos:column="22">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="273" pos:column="25">j</name> <op:operator pos:line="273" pos:column="27">&lt;</op:operator> <name pos:line="273" pos:column="29">BITBLK</name></expr>;</condition> <incr><expr><name pos:line="273" pos:column="37">j</name><op:operator pos:line="273" pos:column="38">++</op:operator></expr></incr>)
		<expr_stmt><expr><name><name pos:line="274" pos:column="17">bittab</name><index pos:line="274" pos:column="23">[<expr><name pos:line="274" pos:column="24">j</name></expr>]</index></name> <op:operator pos:line="274" pos:column="27">=</op:operator> <lit:literal type="number" pos:line="274" pos:column="29">0</lit:literal></expr>;</expr_stmt></for>
}</block></function>

<function><type><name pos:line="277" pos:column="1">void</name></type> <name><name pos:line="277" pos:column="6">RESearch</name><op:operator pos:line="277" pos:column="14">::</op:operator><name pos:line="277" pos:column="16">Clear</name></name><parameter_list pos:line="277" pos:column="21">()</parameter_list> <block pos:line="277" pos:column="24">{
	<for pos:line="278" pos:column="9">for (<init><decl><type><name pos:line="278" pos:column="14">int</name></type> <name pos:line="278" pos:column="18">i</name> <init pos:line="278" pos:column="20">= <expr><lit:literal type="number" pos:line="278" pos:column="22">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="278" pos:column="25">i</name> <op:operator pos:line="278" pos:column="27">&lt;</op:operator> <name pos:line="278" pos:column="29">MAXTAG</name></expr>;</condition> <incr><expr><name pos:line="278" pos:column="37">i</name><op:operator pos:line="278" pos:column="38">++</op:operator></expr></incr>) <block pos:line="278" pos:column="42">{
		<expr_stmt><expr><op:operator pos:line="279" pos:column="17">delete</op:operator> <index pos:line="279" pos:column="24">[]</index><name><name pos:line="279" pos:column="26">pat</name><index pos:line="279" pos:column="29">[<expr><name pos:line="279" pos:column="30">i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name pos:line="280" pos:column="17">pat</name><index pos:line="280" pos:column="20">[<expr><name pos:line="280" pos:column="21">i</name></expr>]</index></name> <op:operator pos:line="280" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="280" pos:column="26">0</lit:literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name pos:line="281" pos:column="17">bopat</name><index pos:line="281" pos:column="22">[<expr><name pos:line="281" pos:column="23">i</name></expr>]</index></name> <op:operator pos:line="281" pos:column="26">=</op:operator> <name pos:line="281" pos:column="28">NOTFOUND</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name pos:line="282" pos:column="17">eopat</name><index pos:line="282" pos:column="22">[<expr><name pos:line="282" pos:column="23">i</name></expr>]</index></name> <op:operator pos:line="282" pos:column="26">=</op:operator> <name pos:line="282" pos:column="28">NOTFOUND</name></expr>;</expr_stmt>
	}</block></for>
}</block></function>

<function><type><name pos:line="286" pos:column="1">bool</name></type> <name><name pos:line="286" pos:column="6">RESearch</name><op:operator pos:line="286" pos:column="14">::</op:operator><name pos:line="286" pos:column="16">GrabMatches</name></name><parameter_list pos:line="286" pos:column="27">(<param><decl><type><name pos:line="286" pos:column="28">CharacterIndexer</name> <type:modifier pos:line="286" pos:column="45">&amp;</type:modifier></type><name pos:line="286" pos:column="46">ci</name></decl></param>)</parameter_list> <block pos:line="286" pos:column="50">{
	<decl_stmt><decl><type><name pos:line="287" pos:column="9">bool</name></type> <name pos:line="287" pos:column="14">success</name> <init pos:line="287" pos:column="22">= <expr><lit:literal type="boolean" pos:line="287" pos:column="24">true</lit:literal></expr></init></decl>;</decl_stmt>
	<for pos:line="288" pos:column="9">for (<init><decl><type><name pos:line="288" pos:column="14">unsigned</name> <name pos:line="288" pos:column="23">int</name></type> <name pos:line="288" pos:column="27">i</name> <init pos:line="288" pos:column="29">= <expr><lit:literal type="number" pos:line="288" pos:column="31">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="288" pos:column="34">i</name> <op:operator pos:line="288" pos:column="36">&lt;</op:operator> <name pos:line="288" pos:column="38">MAXTAG</name></expr>;</condition> <incr><expr><name pos:line="288" pos:column="46">i</name><op:operator pos:line="288" pos:column="47">++</op:operator></expr></incr>) <block pos:line="288" pos:column="51">{
		<if pos:line="289" pos:column="17">if <condition pos:line="289" pos:column="20">(<expr><op:operator pos:line="289" pos:column="21">(</op:operator><name><name pos:line="289" pos:column="22">bopat</name><index pos:line="289" pos:column="27">[<expr><name pos:line="289" pos:column="28">i</name></expr>]</index></name> <op:operator pos:line="289" pos:column="31">!=</op:operator> <name pos:line="289" pos:column="34">NOTFOUND</name><op:operator pos:line="289" pos:column="42">)</op:operator> <op:operator pos:line="289" pos:column="44">&amp;&amp;</op:operator> <op:operator pos:line="289" pos:column="47">(</op:operator><name><name pos:line="289" pos:column="48">eopat</name><index pos:line="289" pos:column="53">[<expr><name pos:line="289" pos:column="54">i</name></expr>]</index></name> <op:operator pos:line="289" pos:column="57">!=</op:operator> <name pos:line="289" pos:column="60">NOTFOUND</name><op:operator pos:line="289" pos:column="68">)</op:operator></expr>)</condition><then pos:line="289" pos:column="70"> <block pos:line="289" pos:column="71">{
			<decl_stmt><decl><type><name pos:line="290" pos:column="25">unsigned</name> <name pos:line="290" pos:column="34">int</name></type> <name pos:line="290" pos:column="38">len</name> <init pos:line="290" pos:column="42">= <expr><name><name pos:line="290" pos:column="44">eopat</name><index pos:line="290" pos:column="49">[<expr><name pos:line="290" pos:column="50">i</name></expr>]</index></name> <op:operator pos:line="290" pos:column="53">-</op:operator> <name><name pos:line="290" pos:column="55">bopat</name><index pos:line="290" pos:column="60">[<expr><name pos:line="290" pos:column="61">i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name><name pos:line="291" pos:column="25">pat</name><index pos:line="291" pos:column="28">[<expr><name pos:line="291" pos:column="29">i</name></expr>]</index></name> <op:operator pos:line="291" pos:column="32">=</op:operator> <op:operator pos:line="291" pos:column="34">new</op:operator> <name><name pos:line="291" pos:column="38">char</name><index pos:line="291" pos:column="42">[<expr><name pos:line="291" pos:column="43">len</name> <op:operator pos:line="291" pos:column="47">+</op:operator> <lit:literal type="number" pos:line="291" pos:column="49">1</lit:literal></expr>]</index></name></expr>;</expr_stmt>
			<if pos:line="292" pos:column="25">if <condition pos:line="292" pos:column="28">(<expr><name><name pos:line="292" pos:column="29">pat</name><index pos:line="292" pos:column="32">[<expr><name pos:line="292" pos:column="33">i</name></expr>]</index></name></expr>)</condition><then pos:line="292" pos:column="36"> <block pos:line="292" pos:column="37">{
				<for pos:line="293" pos:column="33">for (<init><decl><type><name pos:line="293" pos:column="38">unsigned</name> <name pos:line="293" pos:column="47">int</name></type> <name pos:line="293" pos:column="51">j</name> <init pos:line="293" pos:column="53">= <expr><lit:literal type="number" pos:line="293" pos:column="55">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="293" pos:column="58">j</name> <op:operator pos:line="293" pos:column="60">&lt;</op:operator> <name pos:line="293" pos:column="62">len</name></expr>;</condition> <incr><expr><name pos:line="293" pos:column="67">j</name><op:operator pos:line="293" pos:column="68">++</op:operator></expr></incr>)
					<expr_stmt><expr><name><name pos:line="294" pos:column="41">pat</name><index pos:line="294" pos:column="44">[<expr><name pos:line="294" pos:column="45">i</name></expr>]</index><index pos:line="294" pos:column="47">[<expr><name pos:line="294" pos:column="48">j</name></expr>]</index></name> <op:operator pos:line="294" pos:column="51">=</op:operator> <call><name><name pos:line="294" pos:column="53">ci</name><op:operator pos:line="294" pos:column="55">.</op:operator><name pos:line="294" pos:column="56">CharAt</name></name><argument_list pos:line="294" pos:column="62">(<argument><expr><name><name pos:line="294" pos:column="63">bopat</name><index pos:line="294" pos:column="68">[<expr><name pos:line="294" pos:column="69">i</name></expr>]</index></name> <op:operator pos:line="294" pos:column="72">+</op:operator> <name pos:line="294" pos:column="74">j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
				<expr_stmt><expr><name><name pos:line="295" pos:column="33">pat</name><index pos:line="295" pos:column="36">[<expr><name pos:line="295" pos:column="37">i</name></expr>]</index><index pos:line="295" pos:column="39">[<expr><name pos:line="295" pos:column="40">len</name></expr>]</index></name> <op:operator pos:line="295" pos:column="45">=</op:operator> <lit:literal type="char" pos:line="295" pos:column="47">'\0'</lit:literal></expr>;</expr_stmt>
			}</block></then> <else pos:line="296" pos:column="27">else <block pos:line="296" pos:column="32">{
				<expr_stmt><expr><name pos:line="297" pos:column="33">success</name> <op:operator pos:line="297" pos:column="41">=</op:operator> <lit:literal type="boolean" pos:line="297" pos:column="43">false</lit:literal></expr>;</expr_stmt>
			}</block></else></if>
		}</block></then></if>
	}</block></for>
	<return pos:line="301" pos:column="9">return <expr><name pos:line="301" pos:column="16">success</name></expr>;</return>
}</block></function>

<function><type><name pos:line="304" pos:column="1">void</name></type> <name><name pos:line="304" pos:column="6">RESearch</name><op:operator pos:line="304" pos:column="14">::</op:operator><name pos:line="304" pos:column="16">ChSet</name></name><parameter_list pos:line="304" pos:column="21">(<param><decl><type><name pos:line="304" pos:column="22">unsigned</name> <name pos:line="304" pos:column="31">char</name></type> <name pos:line="304" pos:column="36">c</name></decl></param>)</parameter_list> <block pos:line="304" pos:column="39">{
	<expr_stmt><expr><name><name pos:line="305" pos:column="9">bittab</name><index pos:line="305" pos:column="15">[<expr><op:operator pos:line="305" pos:column="16">(</op:operator><op:operator pos:line="305" pos:column="17">(</op:operator><name pos:line="305" pos:column="18">c</name><op:operator pos:line="305" pos:column="19">)</op:operator> <op:operator pos:line="305" pos:column="21">&amp;</op:operator> <name pos:line="305" pos:column="23">BLKIND</name><op:operator pos:line="305" pos:column="29">)</op:operator> <op:operator pos:line="305" pos:column="31">&gt;&gt;</op:operator> <lit:literal type="number" pos:line="305" pos:column="34">3</lit:literal></expr>]</index></name> <op:operator pos:line="305" pos:column="37">|=</op:operator> <name><name pos:line="305" pos:column="40">bitarr</name><index pos:line="305" pos:column="46">[<expr><op:operator pos:line="305" pos:column="47">(</op:operator><name pos:line="305" pos:column="48">c</name><op:operator pos:line="305" pos:column="49">)</op:operator> <op:operator pos:line="305" pos:column="51">&amp;</op:operator> <name pos:line="305" pos:column="53">BITIND</name></expr>]</index></name></expr>;</expr_stmt>
}</block></function>

<function><type><name pos:line="308" pos:column="1">void</name></type> <name><name pos:line="308" pos:column="6">RESearch</name><op:operator pos:line="308" pos:column="14">::</op:operator><name pos:line="308" pos:column="16">ChSetWithCase</name></name><parameter_list pos:line="308" pos:column="29">(<param><decl><type><name pos:line="308" pos:column="30">unsigned</name> <name pos:line="308" pos:column="39">char</name></type> <name pos:line="308" pos:column="44">c</name></decl></param>, <param><decl><type><name pos:line="308" pos:column="47">bool</name></type> <name pos:line="308" pos:column="52">caseSensitive</name></decl></param>)</parameter_list> <block pos:line="308" pos:column="67">{
	<if pos:line="309" pos:column="9">if <condition pos:line="309" pos:column="12">(<expr><name pos:line="309" pos:column="13">caseSensitive</name></expr>)</condition><then pos:line="309" pos:column="27"> <block pos:line="309" pos:column="28">{
		<expr_stmt><expr><call><name pos:line="310" pos:column="17">ChSet</name><argument_list pos:line="310" pos:column="22">(<argument><expr><name pos:line="310" pos:column="23">c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then> <else pos:line="311" pos:column="11">else <block pos:line="311" pos:column="16">{
		<if pos:line="312" pos:column="17">if <condition pos:line="312" pos:column="20">(<expr><op:operator pos:line="312" pos:column="21">(</op:operator><name pos:line="312" pos:column="22">c</name> <op:operator pos:line="312" pos:column="24">&gt;=</op:operator> <lit:literal type="char" pos:line="312" pos:column="27">'a'</lit:literal><op:operator pos:line="312" pos:column="30">)</op:operator> <op:operator pos:line="312" pos:column="32">&amp;&amp;</op:operator> <op:operator pos:line="312" pos:column="35">(</op:operator><name pos:line="312" pos:column="36">c</name> <op:operator pos:line="312" pos:column="38">&lt;=</op:operator> <lit:literal type="char" pos:line="312" pos:column="41">'z'</lit:literal><op:operator pos:line="312" pos:column="44">)</op:operator></expr>)</condition><then pos:line="312" pos:column="46"> <block pos:line="312" pos:column="47">{
			<expr_stmt><expr><call><name pos:line="313" pos:column="25">ChSet</name><argument_list pos:line="313" pos:column="30">(<argument><expr><name pos:line="313" pos:column="31">c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name pos:line="314" pos:column="25">ChSet</name><argument_list pos:line="314" pos:column="30">(<argument pos:line="314" pos:column="31">static_cast&lt;unsigned char&gt;(c - 'a' + 'A')</argument>)</argument_list></macro><empty_stmt pos:line="314" pos:column="73">;</empty_stmt>
		}</block></then> <else pos:line="315" pos:column="19">else <if pos:line="315" pos:column="24">if <condition pos:line="315" pos:column="27">(<expr><op:operator pos:line="315" pos:column="28">(</op:operator><name pos:line="315" pos:column="29">c</name> <op:operator pos:line="315" pos:column="31">&gt;=</op:operator> <lit:literal type="char" pos:line="315" pos:column="34">'A'</lit:literal><op:operator pos:line="315" pos:column="37">)</op:operator> <op:operator pos:line="315" pos:column="39">&amp;&amp;</op:operator> <op:operator pos:line="315" pos:column="42">(</op:operator><name pos:line="315" pos:column="43">c</name> <op:operator pos:line="315" pos:column="45">&lt;=</op:operator> <lit:literal type="char" pos:line="315" pos:column="48">'Z'</lit:literal><op:operator pos:line="315" pos:column="51">)</op:operator></expr>)</condition><then pos:line="315" pos:column="53"> <block pos:line="315" pos:column="54">{
			<expr_stmt><expr><call><name pos:line="316" pos:column="25">ChSet</name><argument_list pos:line="316" pos:column="30">(<argument><expr><name pos:line="316" pos:column="31">c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name pos:line="317" pos:column="25">ChSet</name><argument_list pos:line="317" pos:column="30">(<argument pos:line="317" pos:column="31">static_cast&lt;unsigned char&gt;(c - 'A' + 'a')</argument>)</argument_list></macro><empty_stmt pos:line="317" pos:column="73">;</empty_stmt>
		}</block></then> <else pos:line="318" pos:column="19">else <block pos:line="318" pos:column="24">{
			<expr_stmt><expr><call><name pos:line="319" pos:column="25">ChSet</name><argument_list pos:line="319" pos:column="30">(<argument><expr><name pos:line="319" pos:column="31">c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></else></if></else></if>
	}</block></else></if>
}</block></function>

<function><type><name pos:line="324" pos:column="1">unsigned</name> <name pos:line="324" pos:column="10">char</name></type> <name pos:line="324" pos:column="15">escapeValue</name><parameter_list pos:line="324" pos:column="26">(<param><decl><type><name pos:line="324" pos:column="27">unsigned</name> <name pos:line="324" pos:column="36">char</name></type> <name pos:line="324" pos:column="41">ch</name></decl></param>)</parameter_list> <block pos:line="324" pos:column="45">{
	<switch pos:line="325" pos:column="9">switch <condition pos:line="325" pos:column="16">(<expr><name pos:line="325" pos:column="17">ch</name></expr>)</condition> <block pos:line="325" pos:column="21">{
	<case pos:line="326" pos:column="9">case <expr><lit:literal type="char" pos:line="326" pos:column="14">'a'</lit:literal></expr>:	<return pos:line="326" pos:column="25">return <expr><lit:literal type="char" pos:line="326" pos:column="32">'\a'</lit:literal></expr>;</return>
	</case><case pos:line="327" pos:column="9">case <expr><lit:literal type="char" pos:line="327" pos:column="14">'b'</lit:literal></expr>:	<return pos:line="327" pos:column="25">return <expr><lit:literal type="char" pos:line="327" pos:column="32">'\b'</lit:literal></expr>;</return>
	</case><case pos:line="328" pos:column="9">case <expr><lit:literal type="char" pos:line="328" pos:column="14">'f'</lit:literal></expr>:	<return pos:line="328" pos:column="25">return <expr><lit:literal type="char" pos:line="328" pos:column="32">'\f'</lit:literal></expr>;</return>
	</case><case pos:line="329" pos:column="9">case <expr><lit:literal type="char" pos:line="329" pos:column="14">'n'</lit:literal></expr>:	<return pos:line="329" pos:column="25">return <expr><lit:literal type="char" pos:line="329" pos:column="32">'\n'</lit:literal></expr>;</return>
	</case><case pos:line="330" pos:column="9">case <expr><lit:literal type="char" pos:line="330" pos:column="14">'r'</lit:literal></expr>:	<return pos:line="330" pos:column="25">return <expr><lit:literal type="char" pos:line="330" pos:column="32">'\r'</lit:literal></expr>;</return>
	</case><case pos:line="331" pos:column="9">case <expr><lit:literal type="char" pos:line="331" pos:column="14">'t'</lit:literal></expr>:	<return pos:line="331" pos:column="25">return <expr><lit:literal type="char" pos:line="331" pos:column="32">'\t'</lit:literal></expr>;</return>
	</case><case pos:line="332" pos:column="9">case <expr><lit:literal type="char" pos:line="332" pos:column="14">'v'</lit:literal></expr>:	<return pos:line="332" pos:column="25">return <expr><lit:literal type="char" pos:line="332" pos:column="32">'\v'</lit:literal></expr>;</return>
	</case>}</block></switch>
	<return pos:line="334" pos:column="9">return <expr><lit:literal type="number" pos:line="334" pos:column="16">0</lit:literal></expr>;</return>
}</block></function>

<function><type><specifier pos:line="337" pos:column="1">static</specifier> <name pos:line="337" pos:column="8">int</name></type> <name pos:line="337" pos:column="12">GetHexaChar</name><parameter_list pos:line="337" pos:column="23">(<param><decl><type><name pos:line="337" pos:column="24">unsigned</name> <name pos:line="337" pos:column="33">char</name></type> <name pos:line="337" pos:column="38">hd1</name></decl></param>, <param><decl><type><name pos:line="337" pos:column="43">unsigned</name> <name pos:line="337" pos:column="52">char</name></type> <name pos:line="337" pos:column="57">hd2</name></decl></param>)</parameter_list> <block pos:line="337" pos:column="62">{
	<decl_stmt><decl><type><name pos:line="338" pos:column="9">int</name></type> <name pos:line="338" pos:column="13">hexValue</name> <init pos:line="338" pos:column="22">= <expr><lit:literal type="number" pos:line="338" pos:column="24">0</lit:literal></expr></init></decl>;</decl_stmt>
	<if pos:line="339" pos:column="9">if <condition pos:line="339" pos:column="12">(<expr><name pos:line="339" pos:column="13">hd1</name> <op:operator pos:line="339" pos:column="17">&gt;=</op:operator> <lit:literal type="char" pos:line="339" pos:column="20">'0'</lit:literal> <op:operator pos:line="339" pos:column="24">&amp;&amp;</op:operator> <name pos:line="339" pos:column="27">hd1</name> <op:operator pos:line="339" pos:column="31">&lt;=</op:operator> <lit:literal type="char" pos:line="339" pos:column="34">'9'</lit:literal></expr>)</condition><then pos:line="339" pos:column="38"> <block pos:line="339" pos:column="39">{
		<expr_stmt><expr><name pos:line="340" pos:column="17">hexValue</name> <op:operator pos:line="340" pos:column="26">+=</op:operator> <lit:literal type="number" pos:line="340" pos:column="29">16</lit:literal> <op:operator pos:line="340" pos:column="32">*</op:operator> <op:operator pos:line="340" pos:column="34">(</op:operator><name pos:line="340" pos:column="35">hd1</name> <op:operator pos:line="340" pos:column="39">-</op:operator> <lit:literal type="char" pos:line="340" pos:column="41">'0'</lit:literal><op:operator pos:line="340" pos:column="44">)</op:operator></expr>;</expr_stmt>
	}</block></then> <else pos:line="341" pos:column="11">else <if pos:line="341" pos:column="16">if <condition pos:line="341" pos:column="19">(<expr><name pos:line="341" pos:column="20">hd1</name> <op:operator pos:line="341" pos:column="24">&gt;=</op:operator> <lit:literal type="char" pos:line="341" pos:column="27">'A'</lit:literal> <op:operator pos:line="341" pos:column="31">&amp;&amp;</op:operator> <name pos:line="341" pos:column="34">hd1</name> <op:operator pos:line="341" pos:column="38">&lt;=</op:operator> <lit:literal type="char" pos:line="341" pos:column="41">'F'</lit:literal></expr>)</condition><then pos:line="341" pos:column="45"> <block pos:line="341" pos:column="46">{
		<expr_stmt><expr><name pos:line="342" pos:column="17">hexValue</name> <op:operator pos:line="342" pos:column="26">+=</op:operator> <lit:literal type="number" pos:line="342" pos:column="29">16</lit:literal> <op:operator pos:line="342" pos:column="32">*</op:operator> <op:operator pos:line="342" pos:column="34">(</op:operator><name pos:line="342" pos:column="35">hd1</name> <op:operator pos:line="342" pos:column="39">-</op:operator> <lit:literal type="char" pos:line="342" pos:column="41">'A'</lit:literal> <op:operator pos:line="342" pos:column="45">+</op:operator> <lit:literal type="number" pos:line="342" pos:column="47">10</lit:literal><op:operator pos:line="342" pos:column="49">)</op:operator></expr>;</expr_stmt>
	}</block></then> <else pos:line="343" pos:column="11">else <if pos:line="343" pos:column="16">if <condition pos:line="343" pos:column="19">(<expr><name pos:line="343" pos:column="20">hd1</name> <op:operator pos:line="343" pos:column="24">&gt;=</op:operator> <lit:literal type="char" pos:line="343" pos:column="27">'a'</lit:literal> <op:operator pos:line="343" pos:column="31">&amp;&amp;</op:operator> <name pos:line="343" pos:column="34">hd1</name> <op:operator pos:line="343" pos:column="38">&lt;=</op:operator> <lit:literal type="char" pos:line="343" pos:column="41">'f'</lit:literal></expr>)</condition><then pos:line="343" pos:column="45"> <block pos:line="343" pos:column="46">{
		<expr_stmt><expr><name pos:line="344" pos:column="17">hexValue</name> <op:operator pos:line="344" pos:column="26">+=</op:operator> <lit:literal type="number" pos:line="344" pos:column="29">16</lit:literal> <op:operator pos:line="344" pos:column="32">*</op:operator> <op:operator pos:line="344" pos:column="34">(</op:operator><name pos:line="344" pos:column="35">hd1</name> <op:operator pos:line="344" pos:column="39">-</op:operator> <lit:literal type="char" pos:line="344" pos:column="41">'a'</lit:literal> <op:operator pos:line="344" pos:column="45">+</op:operator> <lit:literal type="number" pos:line="344" pos:column="47">10</lit:literal><op:operator pos:line="344" pos:column="49">)</op:operator></expr>;</expr_stmt>
	}</block></then> <else pos:line="345" pos:column="11">else
		<return pos:line="346" pos:column="17">return <expr><op:operator pos:line="346" pos:column="24">-</op:operator><lit:literal type="number" pos:line="346" pos:column="25">1</lit:literal></expr>;</return></else></if></else></if></else></if>
	<if pos:line="347" pos:column="9">if <condition pos:line="347" pos:column="12">(<expr><name pos:line="347" pos:column="13">hd2</name> <op:operator pos:line="347" pos:column="17">&gt;=</op:operator> <lit:literal type="char" pos:line="347" pos:column="20">'0'</lit:literal> <op:operator pos:line="347" pos:column="24">&amp;&amp;</op:operator> <name pos:line="347" pos:column="27">hd2</name> <op:operator pos:line="347" pos:column="31">&lt;=</op:operator> <lit:literal type="char" pos:line="347" pos:column="34">'9'</lit:literal></expr>)</condition><then pos:line="347" pos:column="38"> <block pos:line="347" pos:column="39">{
		<expr_stmt><expr><name pos:line="348" pos:column="17">hexValue</name> <op:operator pos:line="348" pos:column="26">+=</op:operator> <name pos:line="348" pos:column="29">hd2</name> <op:operator pos:line="348" pos:column="33">-</op:operator> <lit:literal type="char" pos:line="348" pos:column="35">'0'</lit:literal></expr>;</expr_stmt>
	}</block></then> <else pos:line="349" pos:column="11">else <if pos:line="349" pos:column="16">if <condition pos:line="349" pos:column="19">(<expr><name pos:line="349" pos:column="20">hd2</name> <op:operator pos:line="349" pos:column="24">&gt;=</op:operator> <lit:literal type="char" pos:line="349" pos:column="27">'A'</lit:literal> <op:operator pos:line="349" pos:column="31">&amp;&amp;</op:operator> <name pos:line="349" pos:column="34">hd2</name> <op:operator pos:line="349" pos:column="38">&lt;=</op:operator> <lit:literal type="char" pos:line="349" pos:column="41">'F'</lit:literal></expr>)</condition><then pos:line="349" pos:column="45"> <block pos:line="349" pos:column="46">{
		<expr_stmt><expr><name pos:line="350" pos:column="17">hexValue</name> <op:operator pos:line="350" pos:column="26">+=</op:operator> <name pos:line="350" pos:column="29">hd2</name> <op:operator pos:line="350" pos:column="33">-</op:operator> <lit:literal type="char" pos:line="350" pos:column="35">'A'</lit:literal> <op:operator pos:line="350" pos:column="39">+</op:operator> <lit:literal type="number" pos:line="350" pos:column="41">10</lit:literal></expr>;</expr_stmt>
	}</block></then> <else pos:line="351" pos:column="11">else <if pos:line="351" pos:column="16">if <condition pos:line="351" pos:column="19">(<expr><name pos:line="351" pos:column="20">hd2</name> <op:operator pos:line="351" pos:column="24">&gt;=</op:operator> <lit:literal type="char" pos:line="351" pos:column="27">'a'</lit:literal> <op:operator pos:line="351" pos:column="31">&amp;&amp;</op:operator> <name pos:line="351" pos:column="34">hd2</name> <op:operator pos:line="351" pos:column="38">&lt;=</op:operator> <lit:literal type="char" pos:line="351" pos:column="41">'f'</lit:literal></expr>)</condition><then pos:line="351" pos:column="45"> <block pos:line="351" pos:column="46">{
		<expr_stmt><expr><name pos:line="352" pos:column="17">hexValue</name> <op:operator pos:line="352" pos:column="26">+=</op:operator> <name pos:line="352" pos:column="29">hd2</name> <op:operator pos:line="352" pos:column="33">-</op:operator> <lit:literal type="char" pos:line="352" pos:column="35">'a'</lit:literal> <op:operator pos:line="352" pos:column="39">+</op:operator> <lit:literal type="number" pos:line="352" pos:column="41">10</lit:literal></expr>;</expr_stmt>
	}</block></then> <else pos:line="353" pos:column="11">else
		<return pos:line="354" pos:column="17">return <expr><op:operator pos:line="354" pos:column="24">-</op:operator><lit:literal type="number" pos:line="354" pos:column="25">1</lit:literal></expr>;</return></else></if></else></if></else></if>
	<return pos:line="355" pos:column="9">return <expr><name pos:line="355" pos:column="16">hexValue</name></expr>;</return>
}</block></function>

<comment type="block" format="doxygen" pos:line="358" pos:column="1">/**
 * Called when the parser finds a backslash not followed
 * by a valid expression (like \( in non-Posix mode).
 * @param pattern: pointer on the char after the backslash.
 * @param incr: (out) number of chars to skip after expression evaluation.
 * @return the char if it resolves to a simple char,
 * or -1 for a char class. In this case, bittab is changed.
 */</comment>
<function><type><name pos:line="366" pos:column="1">int</name></type> <name><name pos:line="366" pos:column="5">RESearch</name><op:operator pos:line="366" pos:column="13">::</op:operator><name pos:line="366" pos:column="15">GetBackslashExpression</name></name><parameter_list pos:line="366" pos:column="37">(
    <param><decl><type><specifier pos:line="367" pos:column="5">const</specifier> <name pos:line="367" pos:column="11">char</name> <type:modifier pos:line="367" pos:column="16">*</type:modifier></type><name pos:line="367" pos:column="17">pattern</name></decl></param>,
    <param><decl><type><name pos:line="368" pos:column="5">int</name> <type:modifier pos:line="368" pos:column="9">&amp;</type:modifier></type><name pos:line="368" pos:column="10">incr</name></decl></param>)</parameter_list> <block pos:line="368" pos:column="16">{
	<comment type="line" pos:line="369" pos:column="9">// Since error reporting is primitive and messages are not used anyway,</comment>
	<comment type="line" pos:line="370" pos:column="9">// I choose to interpret unexpected syntax in a logical way instead</comment>
	<comment type="line" pos:line="371" pos:column="9">// of reporting errors. Otherwise, we can stick on, eg., PCRE behavior.</comment>
	<expr_stmt><expr><name pos:line="372" pos:column="9">incr</name> <op:operator pos:line="372" pos:column="14">=</op:operator> <lit:literal type="number" pos:line="372" pos:column="16">0</lit:literal></expr>;</expr_stmt>	<comment type="line" pos:line="372" pos:column="25">// Most of the time, will skip the char "naturally".</comment>
	<decl_stmt><decl><type><name pos:line="373" pos:column="9">int</name></type> <name pos:line="373" pos:column="13">c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="374" pos:column="9">int</name></type> <name pos:line="374" pos:column="13">result</name> <init pos:line="374" pos:column="20">= <expr><op:operator pos:line="374" pos:column="22">-</op:operator><lit:literal type="number" pos:line="374" pos:column="23">1</lit:literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="375" pos:column="9">unsigned</name> <name pos:line="375" pos:column="18">char</name></type> <name pos:line="375" pos:column="23">bsc</name> <init pos:line="375" pos:column="27">= <expr><op:operator pos:line="375" pos:column="29">*</op:operator><name pos:line="375" pos:column="30">pattern</name></expr></init></decl>;</decl_stmt>
	<if pos:line="376" pos:column="9">if <condition pos:line="376" pos:column="12">(<expr><op:operator pos:line="376" pos:column="13">!</op:operator><name pos:line="376" pos:column="14">bsc</name></expr>)</condition><then pos:line="376" pos:column="18"> <block pos:line="376" pos:column="19">{
		<comment type="line" pos:line="377" pos:column="17">// Avoid overrun</comment>
		<expr_stmt><expr><name pos:line="378" pos:column="17">result</name> <op:operator pos:line="378" pos:column="24">=</op:operator> <lit:literal type="char" pos:line="378" pos:column="26">'\\'</lit:literal></expr>;</expr_stmt>	<comment type="line" pos:line="378" pos:column="33">// \ at end of pattern, take it literally</comment>
		<return pos:line="379" pos:column="17">return <expr><name pos:line="379" pos:column="24">result</name></expr>;</return>
	}</block></then></if>

	<switch pos:line="382" pos:column="9">switch <condition pos:line="382" pos:column="16">(<expr><name pos:line="382" pos:column="17">bsc</name></expr>)</condition> <block pos:line="382" pos:column="22">{
	<case pos:line="383" pos:column="9">case <expr><lit:literal type="char" pos:line="383" pos:column="14">'a'</lit:literal></expr>:
	</case><case pos:line="384" pos:column="9">case <expr><lit:literal type="char" pos:line="384" pos:column="14">'b'</lit:literal></expr>:
	</case><case pos:line="385" pos:column="9">case <expr><lit:literal type="char" pos:line="385" pos:column="14">'n'</lit:literal></expr>:
	</case><case pos:line="386" pos:column="9">case <expr><lit:literal type="char" pos:line="386" pos:column="14">'f'</lit:literal></expr>:
	</case><case pos:line="387" pos:column="9">case <expr><lit:literal type="char" pos:line="387" pos:column="14">'r'</lit:literal></expr>:
	</case><case pos:line="388" pos:column="9">case <expr><lit:literal type="char" pos:line="388" pos:column="14">'t'</lit:literal></expr>:
	</case><case pos:line="389" pos:column="9">case <expr><lit:literal type="char" pos:line="389" pos:column="14">'v'</lit:literal></expr>:
		<expr_stmt><expr><name pos:line="390" pos:column="17">result</name> <op:operator pos:line="390" pos:column="24">=</op:operator> <call><name pos:line="390" pos:column="26">escapeValue</name><argument_list pos:line="390" pos:column="37">(<argument><expr><name pos:line="390" pos:column="38">bsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break pos:line="391" pos:column="17">break;</break>
	</case><case pos:line="392" pos:column="9">case <expr><lit:literal type="char" pos:line="392" pos:column="14">'x'</lit:literal></expr>: <block pos:line="392" pos:column="19">{
			<decl_stmt><decl><type><name pos:line="393" pos:column="25">unsigned</name> <name pos:line="393" pos:column="34">char</name></type> <name pos:line="393" pos:column="39">hd1</name> <init pos:line="393" pos:column="43">= <expr><op:operator pos:line="393" pos:column="45">*</op:operator><op:operator pos:line="393" pos:column="46">(</op:operator><name pos:line="393" pos:column="47">pattern</name> <op:operator pos:line="393" pos:column="55">+</op:operator> <lit:literal type="number" pos:line="393" pos:column="57">1</lit:literal><op:operator pos:line="393" pos:column="58">)</op:operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name pos:line="394" pos:column="25">unsigned</name> <name pos:line="394" pos:column="34">char</name></type> <name pos:line="394" pos:column="39">hd2</name> <init pos:line="394" pos:column="43">= <expr><op:operator pos:line="394" pos:column="45">*</op:operator><op:operator pos:line="394" pos:column="46">(</op:operator><name pos:line="394" pos:column="47">pattern</name> <op:operator pos:line="394" pos:column="55">+</op:operator> <lit:literal type="number" pos:line="394" pos:column="57">2</lit:literal><op:operator pos:line="394" pos:column="58">)</op:operator></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name pos:line="395" pos:column="25">int</name></type> <name pos:line="395" pos:column="29">hexValue</name> <init pos:line="395" pos:column="38">= <expr><call><name pos:line="395" pos:column="40">GetHexaChar</name><argument_list pos:line="395" pos:column="51">(<argument><expr><name pos:line="395" pos:column="52">hd1</name></expr></argument>, <argument><expr><name pos:line="395" pos:column="57">hd2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if pos:line="396" pos:column="25">if <condition pos:line="396" pos:column="28">(<expr><name pos:line="396" pos:column="29">hexValue</name> <op:operator pos:line="396" pos:column="38">&gt;=</op:operator> <lit:literal type="number" pos:line="396" pos:column="41">0</lit:literal></expr>)</condition><then pos:line="396" pos:column="43"> <block pos:line="396" pos:column="44">{
				<expr_stmt><expr><name pos:line="397" pos:column="33">result</name> <op:operator pos:line="397" pos:column="40">=</op:operator> <name pos:line="397" pos:column="42">hexValue</name></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="398" pos:column="33">incr</name> <op:operator pos:line="398" pos:column="38">=</op:operator> <lit:literal type="number" pos:line="398" pos:column="40">2</lit:literal></expr>;</expr_stmt>	<comment type="line" pos:line="398" pos:column="49">// Must skip the digits</comment>
			}</block></then> <else pos:line="399" pos:column="27">else <block pos:line="399" pos:column="32">{
				<expr_stmt><expr><name pos:line="400" pos:column="33">result</name> <op:operator pos:line="400" pos:column="40">=</op:operator> <lit:literal type="char" pos:line="400" pos:column="42">'x'</lit:literal></expr>;</expr_stmt>	<comment type="line" pos:line="400" pos:column="49">// \x without 2 digits: see it as 'x'</comment>
			}</block></else></if>
		}</block>
		<break pos:line="403" pos:column="17">break;</break>
	</case><case pos:line="404" pos:column="9">case <expr><lit:literal type="char" pos:line="404" pos:column="14">'d'</lit:literal></expr>:
		<for pos:line="405" pos:column="17">for (<init><expr><name pos:line="405" pos:column="22">c</name> <op:operator pos:line="405" pos:column="24">=</op:operator> <lit:literal type="char" pos:line="405" pos:column="26">'0'</lit:literal></expr>;</init> <condition><expr><name pos:line="405" pos:column="31">c</name> <op:operator pos:line="405" pos:column="33">&lt;=</op:operator> <lit:literal type="char" pos:line="405" pos:column="36">'9'</lit:literal></expr>;</condition> <incr><expr><name pos:line="405" pos:column="41">c</name><op:operator pos:line="405" pos:column="42">++</op:operator></expr></incr>) <block pos:line="405" pos:column="46">{
			<macro><name pos:line="406" pos:column="25">ChSet</name><argument_list pos:line="406" pos:column="30">(<argument pos:line="406" pos:column="31">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="406" pos:column="61">;</empty_stmt>
		}</block></for>
		<break pos:line="408" pos:column="17">break;</break>
	</case><case pos:line="409" pos:column="9">case <expr><lit:literal type="char" pos:line="409" pos:column="14">'D'</lit:literal></expr>:
		<for pos:line="410" pos:column="17">for (<init><expr><name pos:line="410" pos:column="22">c</name> <op:operator pos:line="410" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="410" pos:column="26">0</lit:literal></expr>;</init> <condition><expr><name pos:line="410" pos:column="29">c</name> <op:operator pos:line="410" pos:column="31">&lt;</op:operator> <name pos:line="410" pos:column="33">MAXCHR</name></expr>;</condition> <incr><expr><name pos:line="410" pos:column="41">c</name><op:operator pos:line="410" pos:column="42">++</op:operator></expr></incr>) <block pos:line="410" pos:column="46">{
			<if pos:line="411" pos:column="25">if <condition pos:line="411" pos:column="28">(<expr><name><name pos:line="411" pos:column="29">c</name> <argument_list pos:line="411" pos:column="31">&lt; <argument><expr><lit:literal type="char" pos:line="411" pos:column="33">'0'</lit:literal> <op:operator pos:line="411" pos:column="37">||</op:operator> <name pos:line="411" pos:column="40">c</name></expr></argument> &gt;</argument_list></name> <lit:literal type="char" pos:line="411" pos:column="44">'9'</lit:literal></expr>)</condition><then pos:line="411" pos:column="48"> <block pos:line="411" pos:column="49">{
				<macro><name pos:line="412" pos:column="33">ChSet</name><argument_list pos:line="412" pos:column="38">(<argument pos:line="412" pos:column="39">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="412" pos:column="69">;</empty_stmt>
			}</block></then></if>
		}</block></for>
		<break pos:line="415" pos:column="17">break;</break>
	</case><case pos:line="416" pos:column="9">case <expr><lit:literal type="char" pos:line="416" pos:column="14">'s'</lit:literal></expr>:
		<expr_stmt><expr><call><name pos:line="417" pos:column="17">ChSet</name><argument_list pos:line="417" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="417" pos:column="23">' '</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="418" pos:column="17">ChSet</name><argument_list pos:line="418" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="418" pos:column="23">'\t'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="419" pos:column="17">ChSet</name><argument_list pos:line="419" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="419" pos:column="23">'\n'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="420" pos:column="17">ChSet</name><argument_list pos:line="420" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="420" pos:column="23">'\r'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="421" pos:column="17">ChSet</name><argument_list pos:line="421" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="421" pos:column="23">'\f'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name pos:line="422" pos:column="17">ChSet</name><argument_list pos:line="422" pos:column="22">(<argument><expr><lit:literal type="char" pos:line="422" pos:column="23">'\v'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break pos:line="423" pos:column="17">break;</break>
	</case><case pos:line="424" pos:column="9">case <expr><lit:literal type="char" pos:line="424" pos:column="14">'S'</lit:literal></expr>:
		<for pos:line="425" pos:column="17">for (<init><expr><name pos:line="425" pos:column="22">c</name> <op:operator pos:line="425" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="425" pos:column="26">0</lit:literal></expr>;</init> <condition><expr><name pos:line="425" pos:column="29">c</name> <op:operator pos:line="425" pos:column="31">&lt;</op:operator> <name pos:line="425" pos:column="33">MAXCHR</name></expr>;</condition> <incr><expr><name pos:line="425" pos:column="41">c</name><op:operator pos:line="425" pos:column="42">++</op:operator></expr></incr>) <block pos:line="425" pos:column="46">{
			<if pos:line="426" pos:column="25">if <condition pos:line="426" pos:column="28">(<expr><name pos:line="426" pos:column="29">c</name> <op:operator pos:line="426" pos:column="31">!=</op:operator> <lit:literal type="char" pos:line="426" pos:column="34">' '</lit:literal> <op:operator pos:line="426" pos:column="38">&amp;&amp;</op:operator> <op:operator pos:line="426" pos:column="41">!</op:operator><op:operator pos:line="426" pos:column="42">(</op:operator><name pos:line="426" pos:column="43">c</name> <op:operator pos:line="426" pos:column="45">&gt;=</op:operator> <lit:literal type="number" pos:line="426" pos:column="48">0x09</lit:literal> <op:operator pos:line="426" pos:column="53">&amp;&amp;</op:operator> <name pos:line="426" pos:column="56">c</name> <op:operator pos:line="426" pos:column="58">&lt;=</op:operator> <lit:literal type="number" pos:line="426" pos:column="61">0x0D</lit:literal><op:operator pos:line="426" pos:column="65">)</op:operator></expr>)</condition><then pos:line="426" pos:column="67"> <block pos:line="426" pos:column="68">{
				<macro><name pos:line="427" pos:column="33">ChSet</name><argument_list pos:line="427" pos:column="38">(<argument pos:line="427" pos:column="39">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="427" pos:column="69">;</empty_stmt>
			}</block></then></if>
		}</block></for>
		<break pos:line="430" pos:column="17">break;</break>
	</case><case pos:line="431" pos:column="9">case <expr><lit:literal type="char" pos:line="431" pos:column="14">'w'</lit:literal></expr>:
		<for pos:line="432" pos:column="17">for (<init><expr><name pos:line="432" pos:column="22">c</name> <op:operator pos:line="432" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="432" pos:column="26">0</lit:literal></expr>;</init> <condition><expr><name pos:line="432" pos:column="29">c</name> <op:operator pos:line="432" pos:column="31">&lt;</op:operator> <name pos:line="432" pos:column="33">MAXCHR</name></expr>;</condition> <incr><expr><name pos:line="432" pos:column="41">c</name><op:operator pos:line="432" pos:column="42">++</op:operator></expr></incr>) <block pos:line="432" pos:column="46">{
			<if pos:line="433" pos:column="25">if <condition pos:line="433" pos:column="28">(<macro><name pos:line="433" pos:column="29">iswordc</name><argument_list pos:line="433" pos:column="36">(<argument pos:line="433" pos:column="37">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro>)</condition><then pos:line="433" pos:column="68"> <block pos:line="433" pos:column="69">{
				<macro><name pos:line="434" pos:column="33">ChSet</name><argument_list pos:line="434" pos:column="38">(<argument pos:line="434" pos:column="39">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="434" pos:column="69">;</empty_stmt>
			}</block></then></if>
		}</block></for>
		<break pos:line="437" pos:column="17">break;</break>
	</case><case pos:line="438" pos:column="9">case <expr><lit:literal type="char" pos:line="438" pos:column="14">'W'</lit:literal></expr>:
		<for pos:line="439" pos:column="17">for (<init><expr><name pos:line="439" pos:column="22">c</name> <op:operator pos:line="439" pos:column="24">=</op:operator> <lit:literal type="number" pos:line="439" pos:column="26">0</lit:literal></expr>;</init> <condition><expr><name pos:line="439" pos:column="29">c</name> <op:operator pos:line="439" pos:column="31">&lt;</op:operator> <name pos:line="439" pos:column="33">MAXCHR</name></expr>;</condition> <incr><expr><name pos:line="439" pos:column="41">c</name><op:operator pos:line="439" pos:column="42">++</op:operator></expr></incr>) <block pos:line="439" pos:column="46">{
			<if pos:line="440" pos:column="25">if <condition pos:line="440" pos:column="28">(<expr><op:operator pos:line="440" pos:column="29">!</op:operator><macro><name pos:line="440" pos:column="30">iswordc</name><argument_list pos:line="440" pos:column="37">(<argument pos:line="440" pos:column="38">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro></expr>)</condition><then pos:line="440" pos:column="69"> <block pos:line="440" pos:column="70">{
				<macro><name pos:line="441" pos:column="33">ChSet</name><argument_list pos:line="441" pos:column="38">(<argument pos:line="441" pos:column="39">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="441" pos:column="69">;</empty_stmt>
			}</block></then></if>
		}</block></for>
		<break pos:line="444" pos:column="17">break;</break>
	</case><default pos:line="445" pos:column="9">default:
		<expr_stmt><expr><name pos:line="446" pos:column="17">result</name> <op:operator pos:line="446" pos:column="24">=</op:operator> <name pos:line="446" pos:column="26">bsc</name></expr>;</expr_stmt>
	</default>}</block></switch>
	<return pos:line="448" pos:column="9">return <expr><name pos:line="448" pos:column="16">result</name></expr>;</return>
}</block></function>

<function><type><specifier pos:line="451" pos:column="1">const</specifier> <name pos:line="451" pos:column="7">char</name> <type:modifier pos:line="451" pos:column="12">*</type:modifier></type><name><name pos:line="451" pos:column="13">RESearch</name><op:operator pos:line="451" pos:column="21">::</op:operator><name pos:line="451" pos:column="23">Compile</name></name><parameter_list pos:line="451" pos:column="30">(<param><decl><type><specifier pos:line="451" pos:column="31">const</specifier> <name pos:line="451" pos:column="37">char</name> <type:modifier pos:line="451" pos:column="42">*</type:modifier></type><name pos:line="451" pos:column="43">pattern</name></decl></param>, <param><decl><type><name pos:line="451" pos:column="52">int</name></type> <name pos:line="451" pos:column="56">length</name></decl></param>, <param><decl><type><name pos:line="451" pos:column="64">bool</name></type> <name pos:line="451" pos:column="69">caseSensitive</name></decl></param>, <param><decl><type><name pos:line="451" pos:column="84">bool</name></type> <name pos:line="451" pos:column="89">posix</name></decl></param>)</parameter_list> <block pos:line="451" pos:column="96">{
	<decl_stmt><decl><type><name pos:line="452" pos:column="9">char</name> <type:modifier pos:line="452" pos:column="14">*</type:modifier></type><name pos:line="452" pos:column="15">mp</name><init pos:line="452" pos:column="17">=<expr><name pos:line="452" pos:column="18">nfa</name></expr></init></decl>;</decl_stmt>          <comment type="block" pos:line="452" pos:column="32">/* nfa pointer       */</comment>
	<decl_stmt><decl><type><name pos:line="453" pos:column="9">char</name> <type:modifier pos:line="453" pos:column="14">*</type:modifier></type><name pos:line="453" pos:column="15">lp</name></decl>;</decl_stmt>              <comment type="block" pos:line="453" pos:column="32">/* saved pointer     */</comment>
	<decl_stmt><decl><type><name pos:line="454" pos:column="9">char</name> <type:modifier pos:line="454" pos:column="14">*</type:modifier></type><name pos:line="454" pos:column="15">sp</name><init pos:line="454" pos:column="17">=<expr><name pos:line="454" pos:column="18">nfa</name></expr></init></decl>;</decl_stmt>          <comment type="block" pos:line="454" pos:column="32">/* another one       */</comment>
	<decl_stmt><decl><type><name pos:line="455" pos:column="9">char</name> <type:modifier pos:line="455" pos:column="14">*</type:modifier></type><name pos:line="455" pos:column="15">mpMax</name> <init pos:line="455" pos:column="21">= <expr><name pos:line="455" pos:column="23">mp</name> <op:operator pos:line="455" pos:column="26">+</op:operator> <name pos:line="455" pos:column="28">MAXNFA</name> <op:operator pos:line="455" pos:column="35">-</op:operator> <name pos:line="455" pos:column="37">BITBLK</name> <op:operator pos:line="455" pos:column="44">-</op:operator> <lit:literal type="number" pos:line="455" pos:column="46">10</lit:literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name pos:line="457" pos:column="9">int</name></type> <name pos:line="457" pos:column="13">tagi</name> <init pos:line="457" pos:column="18">= <expr><lit:literal type="number" pos:line="457" pos:column="20">0</lit:literal></expr></init></decl>;</decl_stmt>          <comment type="block" pos:line="457" pos:column="32">/* tag stack index   */</comment>
	<decl_stmt><decl><type><name pos:line="458" pos:column="9">int</name></type> <name pos:line="458" pos:column="13">tagc</name> <init pos:line="458" pos:column="18">= <expr><lit:literal type="number" pos:line="458" pos:column="20">1</lit:literal></expr></init></decl>;</decl_stmt>          <comment type="block" pos:line="458" pos:column="32">/* actual tag count  */</comment>

	<decl_stmt><decl><type><name pos:line="460" pos:column="9">int</name></type> <name pos:line="460" pos:column="13">n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="461" pos:column="9">char</name></type> <name pos:line="461" pos:column="14">mask</name></decl>;</decl_stmt>             <comment type="block" pos:line="461" pos:column="32">/* xor mask -CCL/NCL */</comment>
	<decl_stmt><decl><type><name pos:line="462" pos:column="9">int</name></type> <name pos:line="462" pos:column="13">c1</name></decl><op:operator pos:line="462" pos:column="15">,</op:operator> <decl><type ref="prev"/><name pos:line="462" pos:column="17">c2</name></decl><op:operator pos:line="462" pos:column="19">,</op:operator> <decl><type ref="prev"/><name pos:line="462" pos:column="21">prevChar</name></decl>;</decl_stmt>

	<if pos:line="464" pos:column="9">if <condition pos:line="464" pos:column="12">(<expr><op:operator pos:line="464" pos:column="13">!</op:operator><name pos:line="464" pos:column="14">pattern</name> <op:operator pos:line="464" pos:column="22">||</op:operator> <op:operator pos:line="464" pos:column="25">!</op:operator><name pos:line="464" pos:column="26">length</name></expr>)</condition><then pos:line="464" pos:column="33"> <block pos:line="464" pos:column="34">{
		<if pos:line="465" pos:column="17">if <condition pos:line="465" pos:column="20">(<expr><name pos:line="465" pos:column="21">sta</name></expr>)</condition><then pos:line="465" pos:column="25">
			<return pos:line="466" pos:column="25">return <expr><lit:literal type="number" pos:line="466" pos:column="32">0</lit:literal></expr>;</return></then>
		<else pos:line="467" pos:column="17">else
			<return pos:line="468" pos:column="25">return <expr><call><name pos:line="468" pos:column="32">badpat</name><argument_list pos:line="468" pos:column="38">(<argument><expr><lit:literal type="string" pos:line="468" pos:column="39">"No previous regular expression"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
	}</block></then></if>
	<expr_stmt><expr><name pos:line="470" pos:column="9">sta</name> <op:operator pos:line="470" pos:column="13">=</op:operator> <name pos:line="470" pos:column="15">NOP</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier pos:line="472" pos:column="9">const</specifier> <name pos:line="472" pos:column="15">char</name> <type:modifier pos:line="472" pos:column="20">*</type:modifier></type><name pos:line="472" pos:column="21">p</name><init pos:line="472" pos:column="22">=<expr><name pos:line="472" pos:column="23">pattern</name></expr></init></decl>;</decl_stmt>     <comment type="block" pos:line="472" pos:column="36">/* pattern pointer   */</comment>
	<for pos:line="473" pos:column="9">for (<init><decl><type><name pos:line="473" pos:column="14">int</name></type> <name pos:line="473" pos:column="18">i</name><init pos:line="473" pos:column="19">=<expr><lit:literal type="number" pos:line="473" pos:column="20">0</lit:literal></expr></init></decl>;</init> <condition><expr><name pos:line="473" pos:column="23">i</name><op:operator pos:line="473" pos:column="24">&lt;</op:operator><name pos:line="473" pos:column="25">length</name></expr>;</condition> <incr><expr><name pos:line="473" pos:column="33">i</name><op:operator pos:line="473" pos:column="34">++</op:operator></expr><op:operator pos:line="473" pos:column="36">,</op:operator> <expr><name pos:line="473" pos:column="38">p</name><op:operator pos:line="473" pos:column="39">++</op:operator></expr></incr>) <block pos:line="473" pos:column="43">{
		<if pos:line="474" pos:column="17">if <condition pos:line="474" pos:column="20">(<expr><name pos:line="474" pos:column="21">mp</name> <op:operator pos:line="474" pos:column="24">&gt;</op:operator> <name pos:line="474" pos:column="26">mpMax</name></expr>)</condition><then pos:line="474" pos:column="32">
			<return pos:line="475" pos:column="25">return <expr><call><name pos:line="475" pos:column="32">badpat</name><argument_list pos:line="475" pos:column="38">(<argument><expr><lit:literal type="string" pos:line="475" pos:column="39">"Pattern too long"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
		<expr_stmt><expr><name pos:line="476" pos:column="17">lp</name> <op:operator pos:line="476" pos:column="20">=</op:operator> <name pos:line="476" pos:column="22">mp</name></expr>;</expr_stmt>
		<switch pos:line="477" pos:column="17">switch <condition pos:line="477" pos:column="24">(<expr><op:operator pos:line="477" pos:column="25">*</op:operator><name pos:line="477" pos:column="26">p</name></expr>)</condition> <block pos:line="477" pos:column="29">{

		<case pos:line="479" pos:column="17">case <expr><lit:literal type="char" pos:line="479" pos:column="22">'.'</lit:literal></expr>:               <comment type="block" pos:line="479" pos:column="41">/* match any char  */</comment>
			<expr_stmt><expr><op:operator pos:line="480" pos:column="25">*</op:operator><name pos:line="480" pos:column="26">mp</name><op:operator pos:line="480" pos:column="28">++</op:operator> <op:operator pos:line="480" pos:column="31">=</op:operator> <name pos:line="480" pos:column="33">ANY</name></expr>;</expr_stmt>
			<break pos:line="481" pos:column="25">break;</break>

		</case><case pos:line="483" pos:column="17">case <expr><lit:literal type="char" pos:line="483" pos:column="22">'^'</lit:literal></expr>:               <comment type="block" pos:line="483" pos:column="41">/* match beginning */</comment>
			<if pos:line="484" pos:column="25">if <condition pos:line="484" pos:column="28">(<expr><name pos:line="484" pos:column="29">p</name> <op:operator pos:line="484" pos:column="31">==</op:operator> <name pos:line="484" pos:column="34">pattern</name></expr>)</condition><then pos:line="484" pos:column="42">
				<expr_stmt><expr><op:operator pos:line="485" pos:column="33">*</op:operator><name pos:line="485" pos:column="34">mp</name><op:operator pos:line="485" pos:column="36">++</op:operator> <op:operator pos:line="485" pos:column="39">=</op:operator> <name pos:line="485" pos:column="41">BOL</name></expr>;</expr_stmt></then>
			<else pos:line="486" pos:column="25">else <block pos:line="486" pos:column="30">{
				<expr_stmt><expr><op:operator pos:line="487" pos:column="33">*</op:operator><name pos:line="487" pos:column="34">mp</name><op:operator pos:line="487" pos:column="36">++</op:operator> <op:operator pos:line="487" pos:column="39">=</op:operator> <name pos:line="487" pos:column="41">CHR</name></expr>;</expr_stmt>
				<expr_stmt><expr><op:operator pos:line="488" pos:column="33">*</op:operator><name pos:line="488" pos:column="34">mp</name><op:operator pos:line="488" pos:column="36">++</op:operator> <op:operator pos:line="488" pos:column="39">=</op:operator> <op:operator pos:line="488" pos:column="41">*</op:operator><name pos:line="488" pos:column="42">p</name></expr>;</expr_stmt>
			}</block></else></if>
			<break pos:line="490" pos:column="25">break;</break>

		</case><case pos:line="492" pos:column="17">case <expr><lit:literal type="char" pos:line="492" pos:column="22">'$'</lit:literal></expr>:               <comment type="block" pos:line="492" pos:column="41">/* match endofline */</comment>
			<if pos:line="493" pos:column="25">if <condition pos:line="493" pos:column="28">(<expr><op:operator pos:line="493" pos:column="29">!</op:operator><op:operator pos:line="493" pos:column="30">*</op:operator><op:operator pos:line="493" pos:column="31">(</op:operator><name pos:line="493" pos:column="32">p</name><op:operator pos:line="493" pos:column="33">+</op:operator><lit:literal type="number" pos:line="493" pos:column="34">1</lit:literal><op:operator pos:line="493" pos:column="35">)</op:operator></expr>)</condition><then pos:line="493" pos:column="37">
				<expr_stmt><expr><op:operator pos:line="494" pos:column="33">*</op:operator><name pos:line="494" pos:column="34">mp</name><op:operator pos:line="494" pos:column="36">++</op:operator> <op:operator pos:line="494" pos:column="39">=</op:operator> <name pos:line="494" pos:column="41">EOL</name></expr>;</expr_stmt></then>
			<else pos:line="495" pos:column="25">else <block pos:line="495" pos:column="30">{
				<expr_stmt><expr><op:operator pos:line="496" pos:column="33">*</op:operator><name pos:line="496" pos:column="34">mp</name><op:operator pos:line="496" pos:column="36">++</op:operator> <op:operator pos:line="496" pos:column="39">=</op:operator> <name pos:line="496" pos:column="41">CHR</name></expr>;</expr_stmt>
				<expr_stmt><expr><op:operator pos:line="497" pos:column="33">*</op:operator><name pos:line="497" pos:column="34">mp</name><op:operator pos:line="497" pos:column="36">++</op:operator> <op:operator pos:line="497" pos:column="39">=</op:operator> <op:operator pos:line="497" pos:column="41">*</op:operator><name pos:line="497" pos:column="42">p</name></expr>;</expr_stmt>
			}</block></else></if>
			<break pos:line="499" pos:column="25">break;</break>

		</case><case pos:line="501" pos:column="17">case <expr><lit:literal type="char" pos:line="501" pos:column="22">'['</lit:literal></expr>:               <comment type="block" pos:line="501" pos:column="41">/* match char class */</comment>
			<expr_stmt><expr><op:operator pos:line="502" pos:column="25">*</op:operator><name pos:line="502" pos:column="26">mp</name><op:operator pos:line="502" pos:column="28">++</op:operator> <op:operator pos:line="502" pos:column="31">=</op:operator> <name pos:line="502" pos:column="33">CCL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="503" pos:column="25">prevChar</name> <op:operator pos:line="503" pos:column="34">=</op:operator> <lit:literal type="number" pos:line="503" pos:column="36">0</lit:literal></expr>;</expr_stmt>

			<expr_stmt><expr><name pos:line="505" pos:column="25">i</name><op:operator pos:line="505" pos:column="26">++</op:operator></expr>;</expr_stmt>
			<if pos:line="506" pos:column="25">if <condition pos:line="506" pos:column="28">(<expr><op:operator pos:line="506" pos:column="29">*</op:operator><op:operator pos:line="506" pos:column="30">++</op:operator><name pos:line="506" pos:column="32">p</name> <op:operator pos:line="506" pos:column="34">==</op:operator> <lit:literal type="char" pos:line="506" pos:column="37">'^'</lit:literal></expr>)</condition><then pos:line="506" pos:column="41"> <block pos:line="506" pos:column="42">{
				<expr_stmt><expr><name pos:line="507" pos:column="33">mask</name> <op:operator pos:line="507" pos:column="38">=</op:operator> <lit:literal type="char" pos:line="507" pos:column="40">'\377'</lit:literal></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="508" pos:column="33">i</name><op:operator pos:line="508" pos:column="34">++</op:operator></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="509" pos:column="33">p</name><op:operator pos:line="509" pos:column="34">++</op:operator></expr>;</expr_stmt>
			}</block></then> <else pos:line="510" pos:column="27">else
				<expr_stmt><expr><name pos:line="511" pos:column="33">mask</name> <op:operator pos:line="511" pos:column="38">=</op:operator> <lit:literal type="number" pos:line="511" pos:column="40">0</lit:literal></expr>;</expr_stmt></else></if>

			<if pos:line="513" pos:column="25">if <condition pos:line="513" pos:column="28">(<expr><op:operator pos:line="513" pos:column="29">*</op:operator><name pos:line="513" pos:column="30">p</name> <op:operator pos:line="513" pos:column="32">==</op:operator> <lit:literal type="char" pos:line="513" pos:column="35">'-'</lit:literal></expr>)</condition><then pos:line="513" pos:column="39"> <block pos:line="513" pos:column="40">{	<comment type="block" pos:line="513" pos:column="49">/* real dash */</comment>
				<expr_stmt><expr><name pos:line="514" pos:column="33">i</name><op:operator pos:line="514" pos:column="34">++</op:operator></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="515" pos:column="33">prevChar</name> <op:operator pos:line="515" pos:column="42">=</op:operator> <op:operator pos:line="515" pos:column="44">*</op:operator><name pos:line="515" pos:column="45">p</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name pos:line="516" pos:column="33">ChSet</name><argument_list pos:line="516" pos:column="38">(<argument><expr><op:operator pos:line="516" pos:column="39">*</op:operator><name pos:line="516" pos:column="40">p</name><op:operator pos:line="516" pos:column="41">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<if pos:line="518" pos:column="25">if <condition pos:line="518" pos:column="28">(<expr><op:operator pos:line="518" pos:column="29">*</op:operator><name pos:line="518" pos:column="30">p</name> <op:operator pos:line="518" pos:column="32">==</op:operator> <lit:literal type="char" pos:line="518" pos:column="35">']'</lit:literal></expr>)</condition><then pos:line="518" pos:column="39"> <block pos:line="518" pos:column="40">{	<comment type="block" pos:line="518" pos:column="49">/* real brace */</comment>
				<expr_stmt><expr><name pos:line="519" pos:column="33">i</name><op:operator pos:line="519" pos:column="34">++</op:operator></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="520" pos:column="33">prevChar</name> <op:operator pos:line="520" pos:column="42">=</op:operator> <op:operator pos:line="520" pos:column="44">*</op:operator><name pos:line="520" pos:column="45">p</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name pos:line="521" pos:column="33">ChSet</name><argument_list pos:line="521" pos:column="38">(<argument><expr><op:operator pos:line="521" pos:column="39">*</op:operator><name pos:line="521" pos:column="40">p</name><op:operator pos:line="521" pos:column="41">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			}</block></then></if>
			<while pos:line="523" pos:column="25">while <condition pos:line="523" pos:column="31">(<expr><op:operator pos:line="523" pos:column="32">*</op:operator><name pos:line="523" pos:column="33">p</name> <op:operator pos:line="523" pos:column="35">&amp;&amp;</op:operator> <op:operator pos:line="523" pos:column="38">*</op:operator><name pos:line="523" pos:column="39">p</name> <op:operator pos:line="523" pos:column="41">!=</op:operator> <lit:literal type="char" pos:line="523" pos:column="44">']'</lit:literal></expr>)</condition> <block pos:line="523" pos:column="49">{
				<if pos:line="524" pos:column="33">if <condition pos:line="524" pos:column="36">(<expr><op:operator pos:line="524" pos:column="37">*</op:operator><name pos:line="524" pos:column="38">p</name> <op:operator pos:line="524" pos:column="40">==</op:operator> <lit:literal type="char" pos:line="524" pos:column="43">'-'</lit:literal></expr>)</condition><then pos:line="524" pos:column="47"> <block pos:line="524" pos:column="48">{
					<if pos:line="525" pos:column="41">if <condition pos:line="525" pos:column="44">(<expr><name pos:line="525" pos:column="45">prevChar</name> <op:operator pos:line="525" pos:column="54">&lt;</op:operator> <lit:literal type="number" pos:line="525" pos:column="56">0</lit:literal></expr>)</condition><then pos:line="525" pos:column="58"> <block pos:line="525" pos:column="59">{
						<comment type="line" pos:line="526" pos:column="49">// Previous def. was a char class like \d, take dash literally</comment>
						<expr_stmt><expr><name pos:line="527" pos:column="49">prevChar</name> <op:operator pos:line="527" pos:column="58">=</op:operator> <op:operator pos:line="527" pos:column="60">*</op:operator><name pos:line="527" pos:column="61">p</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name pos:line="528" pos:column="49">ChSet</name><argument_list pos:line="528" pos:column="54">(<argument><expr><op:operator pos:line="528" pos:column="55">*</op:operator><name pos:line="528" pos:column="56">p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else pos:line="529" pos:column="43">else <if pos:line="529" pos:column="48">if <condition pos:line="529" pos:column="51">(<expr><op:operator pos:line="529" pos:column="52">*</op:operator><op:operator pos:line="529" pos:column="53">(</op:operator><name pos:line="529" pos:column="54">p</name><op:operator pos:line="529" pos:column="55">+</op:operator><lit:literal type="number" pos:line="529" pos:column="56">1</lit:literal><op:operator pos:line="529" pos:column="57">)</op:operator></expr>)</condition><then pos:line="529" pos:column="59"> <block pos:line="529" pos:column="60">{
						<if pos:line="530" pos:column="49">if <condition pos:line="530" pos:column="52">(<expr><op:operator pos:line="530" pos:column="53">*</op:operator><op:operator pos:line="530" pos:column="54">(</op:operator><name pos:line="530" pos:column="55">p</name><op:operator pos:line="530" pos:column="56">+</op:operator><lit:literal type="number" pos:line="530" pos:column="57">1</lit:literal><op:operator pos:line="530" pos:column="58">)</op:operator> <op:operator pos:line="530" pos:column="60">!=</op:operator> <lit:literal type="char" pos:line="530" pos:column="63">']'</lit:literal></expr>)</condition><then pos:line="530" pos:column="67"> <block pos:line="530" pos:column="68">{
							<expr_stmt><expr><name pos:line="531" pos:column="57">c1</name> <op:operator pos:line="531" pos:column="60">=</op:operator> <name pos:line="531" pos:column="62">prevChar</name> <op:operator pos:line="531" pos:column="71">+</op:operator> <lit:literal type="number" pos:line="531" pos:column="73">1</lit:literal></expr>;</expr_stmt>
							<expr_stmt><expr><name pos:line="532" pos:column="57">i</name><op:operator pos:line="532" pos:column="58">++</op:operator></expr>;</expr_stmt>
							<expr_stmt><expr><name pos:line="533" pos:column="57">c2</name> <op:operator pos:line="533" pos:column="60">=</op:operator> <call><name><name pos:line="533" pos:column="62">static_cast</name><argument_list pos:line="533" pos:column="73">&lt;<argument><expr><name pos:line="533" pos:column="74">unsigned</name> <name pos:line="533" pos:column="83">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="533" pos:column="88">(<argument><expr><op:operator pos:line="533" pos:column="89">*</op:operator><op:operator pos:line="533" pos:column="90">++</op:operator><name pos:line="533" pos:column="92">p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<if pos:line="534" pos:column="57">if <condition pos:line="534" pos:column="60">(<expr><name pos:line="534" pos:column="61">c2</name> <op:operator pos:line="534" pos:column="64">==</op:operator> <lit:literal type="char" pos:line="534" pos:column="67">'\\'</lit:literal></expr>)</condition><then pos:line="534" pos:column="72"> <block pos:line="534" pos:column="73">{
								<if pos:line="535" pos:column="65">if <condition pos:line="535" pos:column="68">(<expr><op:operator pos:line="535" pos:column="69">!</op:operator><op:operator pos:line="535" pos:column="70">*</op:operator><op:operator pos:line="535" pos:column="71">(</op:operator><name pos:line="535" pos:column="72">p</name><op:operator pos:line="535" pos:column="73">+</op:operator><lit:literal type="number" pos:line="535" pos:column="74">1</lit:literal><op:operator pos:line="535" pos:column="75">)</op:operator></expr>)</condition><then pos:line="535" pos:column="77">	<comment type="line" pos:line="535" pos:column="81">// End of RE</comment>
									<return pos:line="536" pos:column="73">return <expr><call><name pos:line="536" pos:column="80">badpat</name><argument_list pos:line="536" pos:column="86">(<argument><expr><lit:literal type="string" pos:line="536" pos:column="87">"Missing ]"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then>
								<else pos:line="537" pos:column="65">else <block pos:line="537" pos:column="70">{
									<expr_stmt><expr><name pos:line="538" pos:column="73">i</name><op:operator pos:line="538" pos:column="74">++</op:operator></expr>;</expr_stmt>
									<expr_stmt><expr><name pos:line="539" pos:column="73">p</name><op:operator pos:line="539" pos:column="74">++</op:operator></expr>;</expr_stmt>
									<decl_stmt><decl><type><name pos:line="540" pos:column="73">int</name></type> <name pos:line="540" pos:column="77">incr</name></decl>;</decl_stmt>
									<expr_stmt><expr><name pos:line="541" pos:column="73">c2</name> <op:operator pos:line="541" pos:column="76">=</op:operator> <call><name pos:line="541" pos:column="78">GetBackslashExpression</name><argument_list pos:line="541" pos:column="100">(<argument><expr><name pos:line="541" pos:column="101">p</name></expr></argument>, <argument><expr><name pos:line="541" pos:column="104">incr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
									<expr_stmt><expr><name pos:line="542" pos:column="73">i</name> <op:operator pos:line="542" pos:column="75">+=</op:operator> <name pos:line="542" pos:column="78">incr</name></expr>;</expr_stmt>
									<expr_stmt><expr><name pos:line="543" pos:column="73">p</name> <op:operator pos:line="543" pos:column="75">+=</op:operator> <name pos:line="543" pos:column="78">incr</name></expr>;</expr_stmt>
									<if pos:line="544" pos:column="73">if <condition pos:line="544" pos:column="76">(<expr><name pos:line="544" pos:column="77">c2</name> <op:operator pos:line="544" pos:column="80">&gt;=</op:operator> <lit:literal type="number" pos:line="544" pos:column="83">0</lit:literal></expr>)</condition><then pos:line="544" pos:column="85"> <block pos:line="544" pos:column="86">{
										<comment type="line" pos:line="545" pos:column="81">// Convention: \c (c is any char) is case sensitive, whatever the option</comment>
										<macro><name pos:line="546" pos:column="81">ChSet</name><argument_list pos:line="546" pos:column="86">(<argument pos:line="546" pos:column="87">static_cast&lt;unsigned char&gt;(c2)</argument>)</argument_list></macro><empty_stmt pos:line="546" pos:column="118">;</empty_stmt>
										<expr_stmt><expr><name pos:line="547" pos:column="81">prevChar</name> <op:operator pos:line="547" pos:column="90">=</op:operator> <name pos:line="547" pos:column="92">c2</name></expr>;</expr_stmt>
									}</block></then> <else pos:line="548" pos:column="75">else <block pos:line="548" pos:column="80">{
										<comment type="line" pos:line="549" pos:column="81">// bittab is already changed</comment>
										<expr_stmt><expr><name pos:line="550" pos:column="81">prevChar</name> <op:operator pos:line="550" pos:column="90">=</op:operator> <op:operator pos:line="550" pos:column="92">-</op:operator><lit:literal type="number" pos:line="550" pos:column="93">1</lit:literal></expr>;</expr_stmt>
									}</block></else></if>
								}</block></else></if>
							}</block></then></if>
							<if pos:line="554" pos:column="57">if <condition pos:line="554" pos:column="60">(<expr><name pos:line="554" pos:column="61">prevChar</name> <op:operator pos:line="554" pos:column="70">&lt;</op:operator> <lit:literal type="number" pos:line="554" pos:column="72">0</lit:literal></expr>)</condition><then pos:line="554" pos:column="74"> <block pos:line="554" pos:column="75">{
								<comment type="line" pos:line="555" pos:column="65">// Char after dash is char class like \d, take dash literally</comment>
								<expr_stmt><expr><name pos:line="556" pos:column="65">prevChar</name> <op:operator pos:line="556" pos:column="74">=</op:operator> <lit:literal type="char" pos:line="556" pos:column="76">'-'</lit:literal></expr>;</expr_stmt>
								<expr_stmt><expr><call><name pos:line="557" pos:column="65">ChSet</name><argument_list pos:line="557" pos:column="70">(<argument><expr><lit:literal type="char" pos:line="557" pos:column="71">'-'</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							}</block></then> <else pos:line="558" pos:column="59">else <block pos:line="558" pos:column="64">{
								<comment type="line" pos:line="559" pos:column="65">// Put all chars between c1 and c2 included in the char set</comment>
								<while pos:line="560" pos:column="65">while <condition pos:line="560" pos:column="71">(<expr><name pos:line="560" pos:column="72">c1</name> <op:operator pos:line="560" pos:column="75">&lt;=</op:operator> <name pos:line="560" pos:column="78">c2</name></expr>)</condition> <block pos:line="560" pos:column="82">{
									<macro><name pos:line="561" pos:column="73">ChSetWithCase</name><argument_list pos:line="561" pos:column="86">(<argument pos:line="561" pos:column="87">static_cast&lt;unsigned char&gt;(c1++)</argument>, <argument pos:line="561" pos:column="121">caseSensitive</argument>)</argument_list></macro><empty_stmt pos:line="561" pos:column="135">;</empty_stmt>
								}</block></while>
							}</block></else></if>
						}</block></then> <else pos:line="564" pos:column="51">else <block pos:line="564" pos:column="56">{
							<comment type="line" pos:line="565" pos:column="57">// Dash before the ], take it literally</comment>
							<expr_stmt><expr><name pos:line="566" pos:column="57">prevChar</name> <op:operator pos:line="566" pos:column="66">=</op:operator> <op:operator pos:line="566" pos:column="68">*</op:operator><name pos:line="566" pos:column="69">p</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name pos:line="567" pos:column="57">ChSet</name><argument_list pos:line="567" pos:column="62">(<argument><expr><op:operator pos:line="567" pos:column="63">*</op:operator><name pos:line="567" pos:column="64">p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						}</block></else></if>
					}</block></then> <else pos:line="569" pos:column="43">else <block pos:line="569" pos:column="48">{
						<return pos:line="570" pos:column="49">return <expr><call><name pos:line="570" pos:column="56">badpat</name><argument_list pos:line="570" pos:column="62">(<argument><expr><lit:literal type="string" pos:line="570" pos:column="63">"Missing ]"</lit:literal></expr></argument>)</argument_list></call></expr>;</return>
					}</block></else></if></else></if>
				}</block></then> <else pos:line="572" pos:column="35">else <if pos:line="572" pos:column="40">if <condition pos:line="572" pos:column="43">(<expr><op:operator pos:line="572" pos:column="44">*</op:operator><name pos:line="572" pos:column="45">p</name> <op:operator pos:line="572" pos:column="47">==</op:operator> <lit:literal type="char" pos:line="572" pos:column="50">'\\'</lit:literal> <op:operator pos:line="572" pos:column="55">&amp;&amp;</op:operator> <op:operator pos:line="572" pos:column="58">*</op:operator><op:operator pos:line="572" pos:column="59">(</op:operator><name pos:line="572" pos:column="60">p</name><op:operator pos:line="572" pos:column="61">+</op:operator><lit:literal type="number" pos:line="572" pos:column="62">1</lit:literal><op:operator pos:line="572" pos:column="63">)</op:operator></expr>)</condition><then pos:line="572" pos:column="65"> <block pos:line="572" pos:column="66">{
					<expr_stmt><expr><name pos:line="573" pos:column="41">i</name><op:operator pos:line="573" pos:column="42">++</op:operator></expr>;</expr_stmt>
					<expr_stmt><expr><name pos:line="574" pos:column="41">p</name><op:operator pos:line="574" pos:column="42">++</op:operator></expr>;</expr_stmt>
					<decl_stmt><decl><type><name pos:line="575" pos:column="41">int</name></type> <name pos:line="575" pos:column="45">incr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name pos:line="576" pos:column="41">int</name></type> <name pos:line="576" pos:column="45">c</name> <init pos:line="576" pos:column="47">= <expr><call><name pos:line="576" pos:column="49">GetBackslashExpression</name><argument_list pos:line="576" pos:column="71">(<argument><expr><name pos:line="576" pos:column="72">p</name></expr></argument>, <argument><expr><name pos:line="576" pos:column="75">incr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name pos:line="577" pos:column="41">i</name> <op:operator pos:line="577" pos:column="43">+=</op:operator> <name pos:line="577" pos:column="46">incr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name pos:line="578" pos:column="41">p</name> <op:operator pos:line="578" pos:column="43">+=</op:operator> <name pos:line="578" pos:column="46">incr</name></expr>;</expr_stmt>
					<if pos:line="579" pos:column="41">if <condition pos:line="579" pos:column="44">(<expr><name pos:line="579" pos:column="45">c</name> <op:operator pos:line="579" pos:column="47">&gt;=</op:operator> <lit:literal type="number" pos:line="579" pos:column="50">0</lit:literal></expr>)</condition><then pos:line="579" pos:column="52"> <block pos:line="579" pos:column="53">{
						<comment type="line" pos:line="580" pos:column="49">// Convention: \c (c is any char) is case sensitive, whatever the option</comment>
						<macro><name pos:line="581" pos:column="49">ChSet</name><argument_list pos:line="581" pos:column="54">(<argument pos:line="581" pos:column="55">static_cast&lt;unsigned char&gt;(c)</argument>)</argument_list></macro><empty_stmt pos:line="581" pos:column="85">;</empty_stmt>
						<expr_stmt><expr><name pos:line="582" pos:column="49">prevChar</name> <op:operator pos:line="582" pos:column="58">=</op:operator> <name pos:line="582" pos:column="60">c</name></expr>;</expr_stmt>
					}</block></then> <else pos:line="583" pos:column="43">else <block pos:line="583" pos:column="48">{
						<comment type="line" pos:line="584" pos:column="49">// bittab is already changed</comment>
						<expr_stmt><expr><name pos:line="585" pos:column="49">prevChar</name> <op:operator pos:line="585" pos:column="58">=</op:operator> <op:operator pos:line="585" pos:column="60">-</op:operator><lit:literal type="number" pos:line="585" pos:column="61">1</lit:literal></expr>;</expr_stmt>
					}</block></else></if>
				}</block></then> <else pos:line="587" pos:column="35">else <block pos:line="587" pos:column="40">{
					<expr_stmt><expr><name pos:line="588" pos:column="41">prevChar</name> <op:operator pos:line="588" pos:column="50">=</op:operator> <call><name><name pos:line="588" pos:column="52">static_cast</name><argument_list pos:line="588" pos:column="63">&lt;<argument><expr><name pos:line="588" pos:column="64">unsigned</name> <name pos:line="588" pos:column="73">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="588" pos:column="78">(<argument><expr><op:operator pos:line="588" pos:column="79">*</op:operator><name pos:line="588" pos:column="80">p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name pos:line="589" pos:column="41">ChSetWithCase</name><argument_list pos:line="589" pos:column="54">(<argument><expr><op:operator pos:line="589" pos:column="55">*</op:operator><name pos:line="589" pos:column="56">p</name></expr></argument>, <argument><expr><name pos:line="589" pos:column="59">caseSensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></else></if></else></if>
				<expr_stmt><expr><name pos:line="591" pos:column="33">i</name><op:operator pos:line="591" pos:column="34">++</op:operator></expr>;</expr_stmt>
				<expr_stmt><expr><name pos:line="592" pos:column="33">p</name><op:operator pos:line="592" pos:column="34">++</op:operator></expr>;</expr_stmt>
			}</block></while>
			<if pos:line="594" pos:column="25">if <condition pos:line="594" pos:column="28">(<expr><op:operator pos:line="594" pos:column="29">!</op:operator><op:operator pos:line="594" pos:column="30">*</op:operator><name pos:line="594" pos:column="31">p</name></expr>)</condition><then pos:line="594" pos:column="33">
				<return pos:line="595" pos:column="33">return <expr><call><name pos:line="595" pos:column="40">badpat</name><argument_list pos:line="595" pos:column="46">(<argument><expr><lit:literal type="string" pos:line="595" pos:column="47">"Missing ]"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>

			<for pos:line="597" pos:column="25">for (<init><expr><name pos:line="597" pos:column="30">n</name> <op:operator pos:line="597" pos:column="32">=</op:operator> <lit:literal type="number" pos:line="597" pos:column="34">0</lit:literal></expr>;</init> <condition><expr><name pos:line="597" pos:column="37">n</name> <op:operator pos:line="597" pos:column="39">&lt;</op:operator> <name pos:line="597" pos:column="41">BITBLK</name></expr>;</condition> <incr><expr><name><name pos:line="597" pos:column="49">bittab</name><index pos:line="597" pos:column="55">[<expr><name pos:line="597" pos:column="56">n</name><op:operator pos:line="597" pos:column="57">++</op:operator></expr>]</index></name> <op:operator pos:line="597" pos:column="61">=</op:operator> <lit:literal type="number" pos:line="597" pos:column="63">0</lit:literal></expr></incr>)
				<expr_stmt><expr><op:operator pos:line="598" pos:column="33">*</op:operator><name pos:line="598" pos:column="34">mp</name><op:operator pos:line="598" pos:column="36">++</op:operator> <op:operator pos:line="598" pos:column="39">=</op:operator> <call><name><name pos:line="598" pos:column="41">static_cast</name><argument_list pos:line="598" pos:column="52">&lt;<argument><expr><name pos:line="598" pos:column="53">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="598" pos:column="58">(<argument><expr><name pos:line="598" pos:column="59">mask</name> <op:operator pos:line="598" pos:column="64">^</op:operator> <name><name pos:line="598" pos:column="66">bittab</name><index pos:line="598" pos:column="72">[<expr><name pos:line="598" pos:column="73">n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

			<break pos:line="600" pos:column="25">break;</break>

		</case><case pos:line="602" pos:column="17">case <expr><lit:literal type="char" pos:line="602" pos:column="22">'*'</lit:literal></expr>:               <comment type="block" pos:line="602" pos:column="41">/* match 0 or more... */</comment>
		</case><case pos:line="603" pos:column="17">case <expr><lit:literal type="char" pos:line="603" pos:column="22">'+'</lit:literal></expr>:               <comment type="block" pos:line="603" pos:column="41">/* match 1 or more... */</comment>
		</case><case pos:line="604" pos:column="17">case <expr><lit:literal type="char" pos:line="604" pos:column="22">'?'</lit:literal></expr>:
			<if pos:line="605" pos:column="25">if <condition pos:line="605" pos:column="28">(<expr><name pos:line="605" pos:column="29">p</name> <op:operator pos:line="605" pos:column="31">==</op:operator> <name pos:line="605" pos:column="34">pattern</name></expr>)</condition><then pos:line="605" pos:column="42">
				<return pos:line="606" pos:column="33">return <expr><call><name pos:line="606" pos:column="40">badpat</name><argument_list pos:line="606" pos:column="46">(<argument><expr><lit:literal type="string" pos:line="606" pos:column="47">"Empty closure"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
			<expr_stmt><expr><name pos:line="607" pos:column="25">lp</name> <op:operator pos:line="607" pos:column="28">=</op:operator> <name pos:line="607" pos:column="30">sp</name></expr>;</expr_stmt>		<comment type="block" pos:line="607" pos:column="49">/* previous opcode */</comment>
			<if pos:line="608" pos:column="25">if <condition pos:line="608" pos:column="28">(<expr><op:operator pos:line="608" pos:column="29">*</op:operator><name pos:line="608" pos:column="30">lp</name> <op:operator pos:line="608" pos:column="33">==</op:operator> <name pos:line="608" pos:column="36">CLO</name> <op:operator pos:line="608" pos:column="40">||</op:operator> <op:operator pos:line="608" pos:column="43">*</op:operator><name pos:line="608" pos:column="44">lp</name> <op:operator pos:line="608" pos:column="47">==</op:operator> <name pos:line="608" pos:column="50">LCLO</name></expr>)</condition><then pos:line="608" pos:column="55">		<comment type="block" pos:line="608" pos:column="65">/* equivalence... */</comment>
				<break pos:line="609" pos:column="33">break;</break></then></if>
			<switch pos:line="610" pos:column="25">switch <condition pos:line="610" pos:column="32">(<expr><op:operator pos:line="610" pos:column="33">*</op:operator><name pos:line="610" pos:column="34">lp</name></expr>)</condition> <block pos:line="610" pos:column="38">{

			<case pos:line="612" pos:column="25">case <expr><name pos:line="612" pos:column="30">BOL</name></expr>:
			</case><case pos:line="613" pos:column="25">case <expr><name pos:line="613" pos:column="30">BOT</name></expr>:
			</case><case pos:line="614" pos:column="25">case <expr><name pos:line="614" pos:column="30">EOT</name></expr>:
			</case><case pos:line="615" pos:column="25">case <expr><name pos:line="615" pos:column="30">BOW</name></expr>:
			</case><case pos:line="616" pos:column="25">case <expr><name pos:line="616" pos:column="30">EOW</name></expr>:
			</case><case pos:line="617" pos:column="25">case <expr><name pos:line="617" pos:column="30">REF</name></expr>:
				<return pos:line="618" pos:column="33">return <expr><call><name pos:line="618" pos:column="40">badpat</name><argument_list pos:line="618" pos:column="46">(<argument><expr><lit:literal type="string" pos:line="618" pos:column="47">"Illegal closure"</lit:literal></expr></argument>)</argument_list></call></expr>;</return>
			</case><default pos:line="619" pos:column="25">default:
				<break pos:line="620" pos:column="33">break;</break>
			</default>}</block></switch>

			<if pos:line="623" pos:column="25">if <condition pos:line="623" pos:column="28">(<expr><op:operator pos:line="623" pos:column="29">*</op:operator><name pos:line="623" pos:column="30">p</name> <op:operator pos:line="623" pos:column="32">==</op:operator> <lit:literal type="char" pos:line="623" pos:column="35">'+'</lit:literal></expr>)</condition><then pos:line="623" pos:column="39">
				<for pos:line="624" pos:column="33">for (<init><expr><name pos:line="624" pos:column="38">sp</name> <op:operator pos:line="624" pos:column="41">=</op:operator> <name pos:line="624" pos:column="43">mp</name></expr>;</init> <condition><expr><name pos:line="624" pos:column="47">lp</name> <op:operator pos:line="624" pos:column="50">&lt;</op:operator> <name pos:line="624" pos:column="52">sp</name></expr>;</condition> <incr><expr><name pos:line="624" pos:column="56">lp</name><op:operator pos:line="624" pos:column="58">++</op:operator></expr></incr>)
					<expr_stmt><expr><op:operator pos:line="625" pos:column="41">*</op:operator><name pos:line="625" pos:column="42">mp</name><op:operator pos:line="625" pos:column="44">++</op:operator> <op:operator pos:line="625" pos:column="47">=</op:operator> <op:operator pos:line="625" pos:column="49">*</op:operator><name pos:line="625" pos:column="50">lp</name></expr>;</expr_stmt></for></then></if>

			<expr_stmt><expr><op:operator pos:line="627" pos:column="25">*</op:operator><name pos:line="627" pos:column="26">mp</name><op:operator pos:line="627" pos:column="28">++</op:operator> <op:operator pos:line="627" pos:column="31">=</op:operator> <name pos:line="627" pos:column="33">END</name></expr>;</expr_stmt>
			<expr_stmt><expr><op:operator pos:line="628" pos:column="25">*</op:operator><name pos:line="628" pos:column="26">mp</name><op:operator pos:line="628" pos:column="28">++</op:operator> <op:operator pos:line="628" pos:column="31">=</op:operator> <name pos:line="628" pos:column="33">END</name></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="629" pos:column="25">sp</name> <op:operator pos:line="629" pos:column="28">=</op:operator> <name pos:line="629" pos:column="30">mp</name></expr>;</expr_stmt>

			<while pos:line="631" pos:column="25">while <condition pos:line="631" pos:column="31">(<expr><op:operator pos:line="631" pos:column="32">--</op:operator><name pos:line="631" pos:column="34">mp</name> <op:operator pos:line="631" pos:column="37">&gt;</op:operator> <name pos:line="631" pos:column="39">lp</name></expr>)</condition>
				<expr_stmt><expr><op:operator pos:line="632" pos:column="33">*</op:operator><name pos:line="632" pos:column="34">mp</name> <op:operator pos:line="632" pos:column="37">=</op:operator> <name><name pos:line="632" pos:column="39">mp</name><index pos:line="632" pos:column="41">[<expr><op:operator pos:line="632" pos:column="42">-</op:operator><lit:literal type="number" pos:line="632" pos:column="43">1</lit:literal></expr>]</index></name></expr>;</expr_stmt></while>
			<if pos:line="633" pos:column="25">if <condition pos:line="633" pos:column="28">(<expr><op:operator pos:line="633" pos:column="29">*</op:operator><name pos:line="633" pos:column="30">p</name> <op:operator pos:line="633" pos:column="32">==</op:operator> <lit:literal type="char" pos:line="633" pos:column="35">'?'</lit:literal></expr>)</condition><then pos:line="633" pos:column="39">          <expr_stmt><expr><op:operator pos:line="633" pos:column="49">*</op:operator><name pos:line="633" pos:column="50">mp</name> <op:operator pos:line="633" pos:column="53">=</op:operator> <name pos:line="633" pos:column="55">CLQ</name></expr>;</expr_stmt></then>
			<else pos:line="634" pos:column="25">else <if pos:line="634" pos:column="30">if <condition pos:line="634" pos:column="33">(<expr><op:operator pos:line="634" pos:column="34">*</op:operator><op:operator pos:line="634" pos:column="35">(</op:operator><name pos:line="634" pos:column="36">p</name><op:operator pos:line="634" pos:column="37">+</op:operator><lit:literal type="number" pos:line="634" pos:column="38">1</lit:literal><op:operator pos:line="634" pos:column="39">)</op:operator> <op:operator pos:line="634" pos:column="41">==</op:operator> <lit:literal type="char" pos:line="634" pos:column="44">'?'</lit:literal></expr>)</condition><then pos:line="634" pos:column="48"> <expr_stmt><expr><op:operator pos:line="634" pos:column="49">*</op:operator><name pos:line="634" pos:column="50">mp</name> <op:operator pos:line="634" pos:column="53">=</op:operator> <name pos:line="634" pos:column="55">LCLO</name></expr>;</expr_stmt></then>
			<else pos:line="635" pos:column="25">else                    <expr_stmt><expr><op:operator pos:line="635" pos:column="49">*</op:operator><name pos:line="635" pos:column="50">mp</name> <op:operator pos:line="635" pos:column="53">=</op:operator> <name pos:line="635" pos:column="55">CLO</name></expr>;</expr_stmt></else></if></else></if>

			<expr_stmt><expr><name pos:line="637" pos:column="25">mp</name> <op:operator pos:line="637" pos:column="28">=</op:operator> <name pos:line="637" pos:column="30">sp</name></expr>;</expr_stmt>
			<break pos:line="638" pos:column="25">break;</break>

		</case><case pos:line="640" pos:column="17">case <expr><lit:literal type="char" pos:line="640" pos:column="22">'\\'</lit:literal></expr>:              <comment type="block" pos:line="640" pos:column="41">/* tags, backrefs... */</comment>
			<expr_stmt><expr><name pos:line="641" pos:column="25">i</name><op:operator pos:line="641" pos:column="26">++</op:operator></expr>;</expr_stmt>
			<switch pos:line="642" pos:column="25">switch <condition pos:line="642" pos:column="32">(<expr><op:operator pos:line="642" pos:column="33">*</op:operator><op:operator pos:line="642" pos:column="34">++</op:operator><name pos:line="642" pos:column="36">p</name></expr>)</condition> <block pos:line="642" pos:column="39">{
			<case pos:line="643" pos:column="25">case <expr><lit:literal type="char" pos:line="643" pos:column="30">'&lt;'</lit:literal></expr>:
				<expr_stmt><expr><op:operator pos:line="644" pos:column="33">*</op:operator><name pos:line="644" pos:column="34">mp</name><op:operator pos:line="644" pos:column="36">++</op:operator> <op:operator pos:line="644" pos:column="39">=</op:operator> <name pos:line="644" pos:column="41">BOW</name></expr>;</expr_stmt>
				<break pos:line="645" pos:column="33">break;</break>
			</case><case pos:line="646" pos:column="25">case <expr><lit:literal type="char" pos:line="646" pos:column="30">'&gt;'</lit:literal></expr>:
				<if pos:line="647" pos:column="33">if <condition pos:line="647" pos:column="36">(<expr><op:operator pos:line="647" pos:column="37">*</op:operator><name pos:line="647" pos:column="38">sp</name> <op:operator pos:line="647" pos:column="41">==</op:operator> <name pos:line="647" pos:column="44">BOW</name></expr>)</condition><then pos:line="647" pos:column="48">
					<return pos:line="648" pos:column="41">return <expr><call><name pos:line="648" pos:column="48">badpat</name><argument_list pos:line="648" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="648" pos:column="55">"Null pattern inside \\&lt;\\&gt;"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<expr_stmt><expr><op:operator pos:line="649" pos:column="33">*</op:operator><name pos:line="649" pos:column="34">mp</name><op:operator pos:line="649" pos:column="36">++</op:operator> <op:operator pos:line="649" pos:column="39">=</op:operator> <name pos:line="649" pos:column="41">EOW</name></expr>;</expr_stmt>
				<break pos:line="650" pos:column="33">break;</break>
			</case><case pos:line="651" pos:column="25">case <expr><lit:literal type="char" pos:line="651" pos:column="30">'1'</lit:literal></expr>:
			</case><case pos:line="652" pos:column="25">case <expr><lit:literal type="char" pos:line="652" pos:column="30">'2'</lit:literal></expr>:
			</case><case pos:line="653" pos:column="25">case <expr><lit:literal type="char" pos:line="653" pos:column="30">'3'</lit:literal></expr>:
			</case><case pos:line="654" pos:column="25">case <expr><lit:literal type="char" pos:line="654" pos:column="30">'4'</lit:literal></expr>:
			</case><case pos:line="655" pos:column="25">case <expr><lit:literal type="char" pos:line="655" pos:column="30">'5'</lit:literal></expr>:
			</case><case pos:line="656" pos:column="25">case <expr><lit:literal type="char" pos:line="656" pos:column="30">'6'</lit:literal></expr>:
			</case><case pos:line="657" pos:column="25">case <expr><lit:literal type="char" pos:line="657" pos:column="30">'7'</lit:literal></expr>:
			</case><case pos:line="658" pos:column="25">case <expr><lit:literal type="char" pos:line="658" pos:column="30">'8'</lit:literal></expr>:
			</case><case pos:line="659" pos:column="25">case <expr><lit:literal type="char" pos:line="659" pos:column="30">'9'</lit:literal></expr>:
				<expr_stmt><expr><name pos:line="660" pos:column="33">n</name> <op:operator pos:line="660" pos:column="35">=</op:operator> <op:operator pos:line="660" pos:column="37">*</op:operator><name pos:line="660" pos:column="38">p</name><op:operator pos:line="660" pos:column="39">-</op:operator><lit:literal type="char" pos:line="660" pos:column="40">'0'</lit:literal></expr>;</expr_stmt>
				<if pos:line="661" pos:column="33">if <condition pos:line="661" pos:column="36">(<expr><name pos:line="661" pos:column="37">tagi</name> <op:operator pos:line="661" pos:column="42">&gt;</op:operator> <lit:literal type="number" pos:line="661" pos:column="44">0</lit:literal> <op:operator pos:line="661" pos:column="46">&amp;&amp;</op:operator> <name><name pos:line="661" pos:column="49">tagstk</name><index pos:line="661" pos:column="55">[<expr><name pos:line="661" pos:column="56">tagi</name></expr>]</index></name> <op:operator pos:line="661" pos:column="62">==</op:operator> <name pos:line="661" pos:column="65">n</name></expr>)</condition><then pos:line="661" pos:column="67">
					<return pos:line="662" pos:column="41">return <expr><call><name pos:line="662" pos:column="48">badpat</name><argument_list pos:line="662" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="662" pos:column="55">"Cyclical reference"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<if pos:line="663" pos:column="33">if <condition pos:line="663" pos:column="36">(<expr><name pos:line="663" pos:column="37">tagc</name> <op:operator pos:line="663" pos:column="42">&gt;</op:operator> <name pos:line="663" pos:column="44">n</name></expr>)</condition><then pos:line="663" pos:column="46"> <block pos:line="663" pos:column="47">{
					<expr_stmt><expr><op:operator pos:line="664" pos:column="41">*</op:operator><name pos:line="664" pos:column="42">mp</name><op:operator pos:line="664" pos:column="44">++</op:operator> <op:operator pos:line="664" pos:column="47">=</op:operator> <call><name><name pos:line="664" pos:column="49">static_cast</name><argument_list pos:line="664" pos:column="60">&lt;<argument><expr><name pos:line="664" pos:column="61">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="664" pos:column="66">(<argument><expr><name pos:line="664" pos:column="67">REF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><op:operator pos:line="665" pos:column="41">*</op:operator><name pos:line="665" pos:column="42">mp</name><op:operator pos:line="665" pos:column="44">++</op:operator> <op:operator pos:line="665" pos:column="47">=</op:operator> <call><name><name pos:line="665" pos:column="49">static_cast</name><argument_list pos:line="665" pos:column="60">&lt;<argument><expr><name pos:line="665" pos:column="61">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="665" pos:column="66">(<argument><expr><name pos:line="665" pos:column="67">n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else pos:line="666" pos:column="35">else
					<return pos:line="667" pos:column="41">return <expr><call><name pos:line="667" pos:column="48">badpat</name><argument_list pos:line="667" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="667" pos:column="55">"Undetermined reference"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
				<break pos:line="668" pos:column="33">break;</break>
			</case><default pos:line="669" pos:column="25">default:
				<if pos:line="670" pos:column="33">if <condition pos:line="670" pos:column="36">(<expr><op:operator pos:line="670" pos:column="37">!</op:operator><name pos:line="670" pos:column="38">posix</name> <op:operator pos:line="670" pos:column="44">&amp;&amp;</op:operator> <op:operator pos:line="670" pos:column="47">*</op:operator><name pos:line="670" pos:column="48">p</name> <op:operator pos:line="670" pos:column="50">==</op:operator> <lit:literal type="char" pos:line="670" pos:column="53">'('</lit:literal></expr>)</condition><then pos:line="670" pos:column="57"> <block pos:line="670" pos:column="58">{
					<if pos:line="671" pos:column="41">if <condition pos:line="671" pos:column="44">(<expr><name pos:line="671" pos:column="45">tagc</name> <op:operator pos:line="671" pos:column="50">&lt;</op:operator> <name pos:line="671" pos:column="52">MAXTAG</name></expr>)</condition><then pos:line="671" pos:column="59"> <block pos:line="671" pos:column="60">{
						<expr_stmt><expr><name><name pos:line="672" pos:column="49">tagstk</name><index pos:line="672" pos:column="55">[<expr><op:operator pos:line="672" pos:column="56">++</op:operator><name pos:line="672" pos:column="58">tagi</name></expr>]</index></name> <op:operator pos:line="672" pos:column="64">=</op:operator> <name pos:line="672" pos:column="66">tagc</name></expr>;</expr_stmt>
						<expr_stmt><expr><op:operator pos:line="673" pos:column="49">*</op:operator><name pos:line="673" pos:column="50">mp</name><op:operator pos:line="673" pos:column="52">++</op:operator> <op:operator pos:line="673" pos:column="55">=</op:operator> <name pos:line="673" pos:column="57">BOT</name></expr>;</expr_stmt>
						<expr_stmt><expr><op:operator pos:line="674" pos:column="49">*</op:operator><name pos:line="674" pos:column="50">mp</name><op:operator pos:line="674" pos:column="52">++</op:operator> <op:operator pos:line="674" pos:column="55">=</op:operator> <call><name><name pos:line="674" pos:column="57">static_cast</name><argument_list pos:line="674" pos:column="68">&lt;<argument><expr><name pos:line="674" pos:column="69">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="674" pos:column="74">(<argument><expr><name pos:line="674" pos:column="75">tagc</name><op:operator pos:line="674" pos:column="79">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else pos:line="675" pos:column="43">else
						<return pos:line="676" pos:column="49">return <expr><call><name pos:line="676" pos:column="56">badpat</name><argument_list pos:line="676" pos:column="62">(<argument><expr><lit:literal type="string" pos:line="676" pos:column="63">"Too many \\(\\) pairs"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
				}</block></then> <else pos:line="677" pos:column="35">else <if pos:line="677" pos:column="40">if <condition pos:line="677" pos:column="43">(<expr><op:operator pos:line="677" pos:column="44">!</op:operator><name pos:line="677" pos:column="45">posix</name> <op:operator pos:line="677" pos:column="51">&amp;&amp;</op:operator> <op:operator pos:line="677" pos:column="54">*</op:operator><name pos:line="677" pos:column="55">p</name> <op:operator pos:line="677" pos:column="57">==</op:operator> <lit:literal type="char" pos:line="677" pos:column="60">')'</lit:literal></expr>)</condition><then pos:line="677" pos:column="64"> <block pos:line="677" pos:column="65">{
					<if pos:line="678" pos:column="41">if <condition pos:line="678" pos:column="44">(<expr><op:operator pos:line="678" pos:column="45">*</op:operator><name pos:line="678" pos:column="46">sp</name> <op:operator pos:line="678" pos:column="49">==</op:operator> <name pos:line="678" pos:column="52">BOT</name></expr>)</condition><then pos:line="678" pos:column="56">
						<return pos:line="679" pos:column="49">return <expr><call><name pos:line="679" pos:column="56">badpat</name><argument_list pos:line="679" pos:column="62">(<argument><expr><lit:literal type="string" pos:line="679" pos:column="63">"Null pattern inside \\(\\)"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
					<if pos:line="680" pos:column="41">if <condition pos:line="680" pos:column="44">(<expr><name pos:line="680" pos:column="45">tagi</name> <op:operator pos:line="680" pos:column="50">&gt;</op:operator> <lit:literal type="number" pos:line="680" pos:column="52">0</lit:literal></expr>)</condition><then pos:line="680" pos:column="54"> <block pos:line="680" pos:column="55">{
						<expr_stmt><expr><op:operator pos:line="681" pos:column="49">*</op:operator><name pos:line="681" pos:column="50">mp</name><op:operator pos:line="681" pos:column="52">++</op:operator> <op:operator pos:line="681" pos:column="55">=</op:operator> <call><name><name pos:line="681" pos:column="57">static_cast</name><argument_list pos:line="681" pos:column="68">&lt;<argument><expr><name pos:line="681" pos:column="69">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="681" pos:column="74">(<argument><expr><name pos:line="681" pos:column="75">EOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><op:operator pos:line="682" pos:column="49">*</op:operator><name pos:line="682" pos:column="50">mp</name><op:operator pos:line="682" pos:column="52">++</op:operator> <op:operator pos:line="682" pos:column="55">=</op:operator> <call><name><name pos:line="682" pos:column="57">static_cast</name><argument_list pos:line="682" pos:column="68">&lt;<argument><expr><name pos:line="682" pos:column="69">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="682" pos:column="74">(<argument><expr><name><name pos:line="682" pos:column="75">tagstk</name><index pos:line="682" pos:column="81">[<expr><name pos:line="682" pos:column="82">tagi</name><op:operator pos:line="682" pos:column="86">--</op:operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else pos:line="683" pos:column="43">else
						<return pos:line="684" pos:column="49">return <expr><call><name pos:line="684" pos:column="56">badpat</name><argument_list pos:line="684" pos:column="62">(<argument><expr><lit:literal type="string" pos:line="684" pos:column="63">"Unmatched \\)"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
				}</block></then> <else pos:line="685" pos:column="35">else <block pos:line="685" pos:column="40">{
					<decl_stmt><decl><type><name pos:line="686" pos:column="41">int</name></type> <name pos:line="686" pos:column="45">incr</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name pos:line="687" pos:column="41">int</name></type> <name pos:line="687" pos:column="45">c</name> <init pos:line="687" pos:column="47">= <expr><call><name pos:line="687" pos:column="49">GetBackslashExpression</name><argument_list pos:line="687" pos:column="71">(<argument><expr><name pos:line="687" pos:column="72">p</name></expr></argument>, <argument><expr><name pos:line="687" pos:column="75">incr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name pos:line="688" pos:column="41">i</name> <op:operator pos:line="688" pos:column="43">+=</op:operator> <name pos:line="688" pos:column="46">incr</name></expr>;</expr_stmt>
					<expr_stmt><expr><name pos:line="689" pos:column="41">p</name> <op:operator pos:line="689" pos:column="43">+=</op:operator> <name pos:line="689" pos:column="46">incr</name></expr>;</expr_stmt>
					<if pos:line="690" pos:column="41">if <condition pos:line="690" pos:column="44">(<expr><name pos:line="690" pos:column="45">c</name> <op:operator pos:line="690" pos:column="47">&gt;=</op:operator> <lit:literal type="number" pos:line="690" pos:column="50">0</lit:literal></expr>)</condition><then pos:line="690" pos:column="52"> <block pos:line="690" pos:column="53">{
						<expr_stmt><expr><op:operator pos:line="691" pos:column="49">*</op:operator><name pos:line="691" pos:column="50">mp</name><op:operator pos:line="691" pos:column="52">++</op:operator> <op:operator pos:line="691" pos:column="55">=</op:operator> <name pos:line="691" pos:column="57">CHR</name></expr>;</expr_stmt>
						<expr_stmt><expr><op:operator pos:line="692" pos:column="49">*</op:operator><name pos:line="692" pos:column="50">mp</name><op:operator pos:line="692" pos:column="52">++</op:operator> <op:operator pos:line="692" pos:column="55">=</op:operator> <call><name><name pos:line="692" pos:column="57">static_cast</name><argument_list pos:line="692" pos:column="68">&lt;<argument><expr><name pos:line="692" pos:column="69">unsigned</name> <name pos:line="692" pos:column="78">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="692" pos:column="83">(<argument><expr><name pos:line="692" pos:column="84">c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					}</block></then> <else pos:line="693" pos:column="43">else <block pos:line="693" pos:column="48">{
						<expr_stmt><expr><op:operator pos:line="694" pos:column="49">*</op:operator><name pos:line="694" pos:column="50">mp</name><op:operator pos:line="694" pos:column="52">++</op:operator> <op:operator pos:line="694" pos:column="55">=</op:operator> <name pos:line="694" pos:column="57">CCL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name pos:line="695" pos:column="49">mask</name> <op:operator pos:line="695" pos:column="54">=</op:operator> <lit:literal type="number" pos:line="695" pos:column="56">0</lit:literal></expr>;</expr_stmt>
						<for pos:line="696" pos:column="49">for (<init><expr><name pos:line="696" pos:column="54">n</name> <op:operator pos:line="696" pos:column="56">=</op:operator> <lit:literal type="number" pos:line="696" pos:column="58">0</lit:literal></expr>;</init> <condition><expr><name pos:line="696" pos:column="61">n</name> <op:operator pos:line="696" pos:column="63">&lt;</op:operator> <name pos:line="696" pos:column="65">BITBLK</name></expr>;</condition> <incr><expr><name><name pos:line="696" pos:column="73">bittab</name><index pos:line="696" pos:column="79">[<expr><name pos:line="696" pos:column="80">n</name><op:operator pos:line="696" pos:column="81">++</op:operator></expr>]</index></name> <op:operator pos:line="696" pos:column="85">=</op:operator> <lit:literal type="number" pos:line="696" pos:column="87">0</lit:literal></expr></incr>)
							<expr_stmt><expr><op:operator pos:line="697" pos:column="57">*</op:operator><name pos:line="697" pos:column="58">mp</name><op:operator pos:line="697" pos:column="60">++</op:operator> <op:operator pos:line="697" pos:column="63">=</op:operator> <call><name><name pos:line="697" pos:column="65">static_cast</name><argument_list pos:line="697" pos:column="76">&lt;<argument><expr><name pos:line="697" pos:column="77">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="697" pos:column="82">(<argument><expr><name pos:line="697" pos:column="83">mask</name> <op:operator pos:line="697" pos:column="88">^</op:operator> <name><name pos:line="697" pos:column="90">bittab</name><index pos:line="697" pos:column="96">[<expr><name pos:line="697" pos:column="97">n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
					}</block></else></if>
				}</block></else></if></else></if>
			</default>}</block></switch>
			<break pos:line="701" pos:column="25">break;</break>

		</case><default pos:line="703" pos:column="17">default :               <comment type="block" pos:line="703" pos:column="41">/* an ordinary char */</comment>
			<if pos:line="704" pos:column="25">if <condition pos:line="704" pos:column="28">(<expr><name pos:line="704" pos:column="29">posix</name> <op:operator pos:line="704" pos:column="35">&amp;&amp;</op:operator> <op:operator pos:line="704" pos:column="38">*</op:operator><name pos:line="704" pos:column="39">p</name> <op:operator pos:line="704" pos:column="41">==</op:operator> <lit:literal type="char" pos:line="704" pos:column="44">'('</lit:literal></expr>)</condition><then pos:line="704" pos:column="48"> <block pos:line="704" pos:column="49">{
				<if pos:line="705" pos:column="33">if <condition pos:line="705" pos:column="36">(<expr><name pos:line="705" pos:column="37">tagc</name> <op:operator pos:line="705" pos:column="42">&lt;</op:operator> <name pos:line="705" pos:column="44">MAXTAG</name></expr>)</condition><then pos:line="705" pos:column="51"> <block pos:line="705" pos:column="52">{
					<expr_stmt><expr><name><name pos:line="706" pos:column="41">tagstk</name><index pos:line="706" pos:column="47">[<expr><op:operator pos:line="706" pos:column="48">++</op:operator><name pos:line="706" pos:column="50">tagi</name></expr>]</index></name> <op:operator pos:line="706" pos:column="56">=</op:operator> <name pos:line="706" pos:column="58">tagc</name></expr>;</expr_stmt>
					<expr_stmt><expr><op:operator pos:line="707" pos:column="41">*</op:operator><name pos:line="707" pos:column="42">mp</name><op:operator pos:line="707" pos:column="44">++</op:operator> <op:operator pos:line="707" pos:column="47">=</op:operator> <name pos:line="707" pos:column="49">BOT</name></expr>;</expr_stmt>
					<expr_stmt><expr><op:operator pos:line="708" pos:column="41">*</op:operator><name pos:line="708" pos:column="42">mp</name><op:operator pos:line="708" pos:column="44">++</op:operator> <op:operator pos:line="708" pos:column="47">=</op:operator> <call><name><name pos:line="708" pos:column="49">static_cast</name><argument_list pos:line="708" pos:column="60">&lt;<argument><expr><name pos:line="708" pos:column="61">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="708" pos:column="66">(<argument><expr><name pos:line="708" pos:column="67">tagc</name><op:operator pos:line="708" pos:column="71">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else pos:line="709" pos:column="35">else
					<return pos:line="710" pos:column="41">return <expr><call><name pos:line="710" pos:column="48">badpat</name><argument_list pos:line="710" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="710" pos:column="55">"Too many () pairs"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
			}</block></then> <else pos:line="711" pos:column="27">else <if pos:line="711" pos:column="32">if <condition pos:line="711" pos:column="35">(<expr><name pos:line="711" pos:column="36">posix</name> <op:operator pos:line="711" pos:column="42">&amp;&amp;</op:operator> <op:operator pos:line="711" pos:column="45">*</op:operator><name pos:line="711" pos:column="46">p</name> <op:operator pos:line="711" pos:column="48">==</op:operator> <lit:literal type="char" pos:line="711" pos:column="51">')'</lit:literal></expr>)</condition><then pos:line="711" pos:column="55"> <block pos:line="711" pos:column="56">{
				<if pos:line="712" pos:column="33">if <condition pos:line="712" pos:column="36">(<expr><op:operator pos:line="712" pos:column="37">*</op:operator><name pos:line="712" pos:column="38">sp</name> <op:operator pos:line="712" pos:column="41">==</op:operator> <name pos:line="712" pos:column="44">BOT</name></expr>)</condition><then pos:line="712" pos:column="48">
					<return pos:line="713" pos:column="41">return <expr><call><name pos:line="713" pos:column="48">badpat</name><argument_list pos:line="713" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="713" pos:column="55">"Null pattern inside ()"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></then></if>
				<if pos:line="714" pos:column="33">if <condition pos:line="714" pos:column="36">(<expr><name pos:line="714" pos:column="37">tagi</name> <op:operator pos:line="714" pos:column="42">&gt;</op:operator> <lit:literal type="number" pos:line="714" pos:column="44">0</lit:literal></expr>)</condition><then pos:line="714" pos:column="46"> <block pos:line="714" pos:column="47">{
					<expr_stmt><expr><op:operator pos:line="715" pos:column="41">*</op:operator><name pos:line="715" pos:column="42">mp</name><op:operator pos:line="715" pos:column="44">++</op:operator> <op:operator pos:line="715" pos:column="47">=</op:operator> <call><name><name pos:line="715" pos:column="49">static_cast</name><argument_list pos:line="715" pos:column="60">&lt;<argument><expr><name pos:line="715" pos:column="61">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="715" pos:column="66">(<argument><expr><name pos:line="715" pos:column="67">EOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><op:operator pos:line="716" pos:column="41">*</op:operator><name pos:line="716" pos:column="42">mp</name><op:operator pos:line="716" pos:column="44">++</op:operator> <op:operator pos:line="716" pos:column="47">=</op:operator> <call><name><name pos:line="716" pos:column="49">static_cast</name><argument_list pos:line="716" pos:column="60">&lt;<argument><expr><name pos:line="716" pos:column="61">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="716" pos:column="66">(<argument><expr><name><name pos:line="716" pos:column="67">tagstk</name><index pos:line="716" pos:column="73">[<expr><name pos:line="716" pos:column="74">tagi</name><op:operator pos:line="716" pos:column="78">--</op:operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then> <else pos:line="717" pos:column="35">else
					<return pos:line="718" pos:column="41">return <expr><call><name pos:line="718" pos:column="48">badpat</name><argument_list pos:line="718" pos:column="54">(<argument><expr><lit:literal type="string" pos:line="718" pos:column="55">"Unmatched )"</lit:literal></expr></argument>)</argument_list></call></expr>;</return></else></if>
			}</block></then> <else pos:line="719" pos:column="27">else <block pos:line="719" pos:column="32">{
				<decl_stmt><decl><type><name pos:line="720" pos:column="33">unsigned</name> <name pos:line="720" pos:column="42">char</name></type> <name pos:line="720" pos:column="47">c</name> <init pos:line="720" pos:column="49">= <expr><op:operator pos:line="720" pos:column="51">*</op:operator><name pos:line="720" pos:column="52">p</name></expr></init></decl>;</decl_stmt>
				<if pos:line="721" pos:column="33">if <condition pos:line="721" pos:column="36">(<expr><op:operator pos:line="721" pos:column="37">!</op:operator><name pos:line="721" pos:column="38">c</name></expr>)</condition><then pos:line="721" pos:column="40">	<comment type="line" pos:line="721" pos:column="41">// End of RE</comment>
					<expr_stmt><expr><name pos:line="722" pos:column="41">c</name> <op:operator pos:line="722" pos:column="43">=</op:operator> <lit:literal type="char" pos:line="722" pos:column="45">'\\'</lit:literal></expr>;</expr_stmt></then></if>	<comment type="line" pos:line="722" pos:column="57">// We take it as raw backslash</comment>
				<if pos:line="723" pos:column="33">if <condition pos:line="723" pos:column="36">(<expr><name pos:line="723" pos:column="37">caseSensitive</name> <op:operator pos:line="723" pos:column="51">||</op:operator> <op:operator pos:line="723" pos:column="54">!</op:operator><call><name pos:line="723" pos:column="55">iswordc</name><argument_list pos:line="723" pos:column="62">(<argument><expr><name pos:line="723" pos:column="63">c</name></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="723" pos:column="66"> <block pos:line="723" pos:column="67">{
					<expr_stmt><expr><op:operator pos:line="724" pos:column="41">*</op:operator><name pos:line="724" pos:column="42">mp</name><op:operator pos:line="724" pos:column="44">++</op:operator> <op:operator pos:line="724" pos:column="47">=</op:operator> <name pos:line="724" pos:column="49">CHR</name></expr>;</expr_stmt>
					<expr_stmt><expr><op:operator pos:line="725" pos:column="41">*</op:operator><name pos:line="725" pos:column="42">mp</name><op:operator pos:line="725" pos:column="44">++</op:operator> <op:operator pos:line="725" pos:column="47">=</op:operator> <name pos:line="725" pos:column="49">c</name></expr>;</expr_stmt>
				}</block></then> <else pos:line="726" pos:column="35">else <block pos:line="726" pos:column="40">{
					<expr_stmt><expr><op:operator pos:line="727" pos:column="41">*</op:operator><name pos:line="727" pos:column="42">mp</name><op:operator pos:line="727" pos:column="44">++</op:operator> <op:operator pos:line="727" pos:column="47">=</op:operator> <name pos:line="727" pos:column="49">CCL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name pos:line="728" pos:column="41">mask</name> <op:operator pos:line="728" pos:column="46">=</op:operator> <lit:literal type="number" pos:line="728" pos:column="48">0</lit:literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name pos:line="729" pos:column="41">ChSetWithCase</name><argument_list pos:line="729" pos:column="54">(<argument><expr><name pos:line="729" pos:column="55">c</name></expr></argument>, <argument><expr><lit:literal type="boolean" pos:line="729" pos:column="58">false</lit:literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<for pos:line="730" pos:column="41">for (<init><expr><name pos:line="730" pos:column="46">n</name> <op:operator pos:line="730" pos:column="48">=</op:operator> <lit:literal type="number" pos:line="730" pos:column="50">0</lit:literal></expr>;</init> <condition><expr><name pos:line="730" pos:column="53">n</name> <op:operator pos:line="730" pos:column="55">&lt;</op:operator> <name pos:line="730" pos:column="57">BITBLK</name></expr>;</condition> <incr><expr><name><name pos:line="730" pos:column="65">bittab</name><index pos:line="730" pos:column="71">[<expr><name pos:line="730" pos:column="72">n</name><op:operator pos:line="730" pos:column="73">++</op:operator></expr>]</index></name> <op:operator pos:line="730" pos:column="77">=</op:operator> <lit:literal type="number" pos:line="730" pos:column="79">0</lit:literal></expr></incr>)
						<expr_stmt><expr><op:operator pos:line="731" pos:column="49">*</op:operator><name pos:line="731" pos:column="50">mp</name><op:operator pos:line="731" pos:column="52">++</op:operator> <op:operator pos:line="731" pos:column="55">=</op:operator> <call><name><name pos:line="731" pos:column="57">static_cast</name><argument_list pos:line="731" pos:column="68">&lt;<argument><expr><name pos:line="731" pos:column="69">char</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="731" pos:column="74">(<argument><expr><name pos:line="731" pos:column="75">mask</name> <op:operator pos:line="731" pos:column="80">^</op:operator> <name><name pos:line="731" pos:column="82">bittab</name><index pos:line="731" pos:column="88">[<expr><name pos:line="731" pos:column="89">n</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
				}</block></else></if>
			}</block></else></if></else></if>
			<break pos:line="734" pos:column="25">break;</break>
		</default>}</block></switch>
		<expr_stmt><expr><name pos:line="736" pos:column="17">sp</name> <op:operator pos:line="736" pos:column="20">=</op:operator> <name pos:line="736" pos:column="22">lp</name></expr>;</expr_stmt>
	}</block></for>
	<if pos:line="738" pos:column="9">if <condition pos:line="738" pos:column="12">(<expr><name pos:line="738" pos:column="13">tagi</name> <op:operator pos:line="738" pos:column="18">&gt;</op:operator> <lit:literal type="number" pos:line="738" pos:column="20">0</lit:literal></expr>)</condition><then pos:line="738" pos:column="22">
		<return pos:line="739" pos:column="17">return <expr><call><name pos:line="739" pos:column="24">badpat</name><argument_list pos:line="739" pos:column="30">(<argument><expr><op:operator pos:line="739" pos:column="31">(</op:operator><name pos:line="739" pos:column="32">posix</name> <op:operator pos:line="739" pos:column="38">?</op:operator> <lit:literal type="string" pos:line="739" pos:column="40">"Unmatched ("</lit:literal> <op:operator pos:line="739" pos:column="54">:</op:operator> <lit:literal type="string" pos:line="739" pos:column="56">"Unmatched \\("</lit:literal><op:operator pos:line="739" pos:column="71">)</op:operator></expr></argument>)</argument_list></call></expr>;</return></then></if>
	<expr_stmt><expr><op:operator pos:line="740" pos:column="9">*</op:operator><name pos:line="740" pos:column="10">mp</name> <op:operator pos:line="740" pos:column="13">=</op:operator> <name pos:line="740" pos:column="15">END</name></expr>;</expr_stmt>
	<expr_stmt><expr><name pos:line="741" pos:column="9">sta</name> <op:operator pos:line="741" pos:column="13">=</op:operator> <name pos:line="741" pos:column="15">OKP</name></expr>;</expr_stmt>
	<return pos:line="742" pos:column="9">return <expr><lit:literal type="number" pos:line="742" pos:column="16">0</lit:literal></expr>;</return>
}</block></function>

<comment type="block" pos:line="745" pos:column="1">/*
 * RESearch::Execute:
 *   execute nfa to find a match.
 *
 *  special cases: (nfa[0])
 *      BOL
 *          Match only once, starting from the
 *          beginning.
 *      CHR
 *          First locate the character without
 *          calling PMatch, and if found, call
 *          PMatch for the remaining string.
 *      END
 *          RESearch::Compile failed, poor luser did not
 *          check for it. Fail fast.
 *
 *  If a match is found, bopat[0] and eopat[0] are set
 *  to the beginning and the end of the matched fragment,
 *  respectively.
 *
 */</comment>
<function><type><name pos:line="766" pos:column="1">int</name></type> <name><name pos:line="766" pos:column="5">RESearch</name><op:operator pos:line="766" pos:column="13">::</op:operator><name pos:line="766" pos:column="15">Execute</name></name><parameter_list pos:line="766" pos:column="22">(<param><decl><type><name pos:line="766" pos:column="23">CharacterIndexer</name> <type:modifier pos:line="766" pos:column="40">&amp;</type:modifier></type><name pos:line="766" pos:column="41">ci</name></decl></param>, <param><decl><type><name pos:line="766" pos:column="45">int</name></type> <name pos:line="766" pos:column="49">lp</name></decl></param>, <param><decl><type><name pos:line="766" pos:column="53">int</name></type> <name pos:line="766" pos:column="57">endp</name></decl></param>)</parameter_list> <block pos:line="766" pos:column="63">{
	<decl_stmt><decl><type><name pos:line="767" pos:column="9">unsigned</name> <name pos:line="767" pos:column="18">char</name></type> <name pos:line="767" pos:column="23">c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="768" pos:column="9">int</name></type> <name pos:line="768" pos:column="13">ep</name> <init pos:line="768" pos:column="16">= <expr><name pos:line="768" pos:column="18">NOTFOUND</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="769" pos:column="9">char</name> <type:modifier pos:line="769" pos:column="14">*</type:modifier></type><name pos:line="769" pos:column="15">ap</name> <init pos:line="769" pos:column="18">= <expr><name pos:line="769" pos:column="20">nfa</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name pos:line="771" pos:column="9">bol</name> <op:operator pos:line="771" pos:column="13">=</op:operator> <name pos:line="771" pos:column="15">lp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name pos:line="772" pos:column="9">failure</name> <op:operator pos:line="772" pos:column="17">=</op:operator> <lit:literal type="number" pos:line="772" pos:column="19">0</lit:literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name pos:line="774" pos:column="9">Clear</name><argument_list pos:line="774" pos:column="14">()</argument_list></call></expr>;</expr_stmt>

	<switch pos:line="776" pos:column="9">switch <condition pos:line="776" pos:column="16">(<expr><op:operator pos:line="776" pos:column="17">*</op:operator><name pos:line="776" pos:column="18">ap</name></expr>)</condition> <block pos:line="776" pos:column="22">{

	<case pos:line="778" pos:column="9">case <expr><name pos:line="778" pos:column="14">BOL</name></expr>:			<comment type="block" pos:line="778" pos:column="41">/* anchored: match from BOL only */</comment>
		<expr_stmt><expr><name pos:line="779" pos:column="17">ep</name> <op:operator pos:line="779" pos:column="20">=</op:operator> <call><name pos:line="779" pos:column="22">PMatch</name><argument_list pos:line="779" pos:column="28">(<argument><expr><name pos:line="779" pos:column="29">ci</name></expr></argument>, <argument><expr><name pos:line="779" pos:column="33">lp</name></expr></argument>, <argument><expr><name pos:line="779" pos:column="37">endp</name></expr></argument>, <argument><expr><name pos:line="779" pos:column="43">ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break pos:line="780" pos:column="17">break;</break>
	</case><case pos:line="781" pos:column="9">case <expr><name pos:line="781" pos:column="14">EOL</name></expr>:			<comment type="block" pos:line="781" pos:column="41">/* just searching for end of line normal path doesn't work */</comment>
		<if pos:line="782" pos:column="17">if <condition pos:line="782" pos:column="20">(<expr><op:operator pos:line="782" pos:column="21">*</op:operator><op:operator pos:line="782" pos:column="22">(</op:operator><name pos:line="782" pos:column="23">ap</name><op:operator pos:line="782" pos:column="25">+</op:operator><lit:literal type="number" pos:line="782" pos:column="26">1</lit:literal><op:operator pos:line="782" pos:column="27">)</op:operator> <op:operator pos:line="782" pos:column="29">==</op:operator> <name pos:line="782" pos:column="32">END</name></expr>)</condition><then pos:line="782" pos:column="36"> <block pos:line="782" pos:column="37">{
			<expr_stmt><expr><name pos:line="783" pos:column="25">lp</name> <op:operator pos:line="783" pos:column="28">=</op:operator> <name pos:line="783" pos:column="30">endp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="784" pos:column="25">ep</name> <op:operator pos:line="784" pos:column="28">=</op:operator> <name pos:line="784" pos:column="30">lp</name></expr>;</expr_stmt>
			<break pos:line="785" pos:column="25">break;</break>
		}</block></then> <else pos:line="786" pos:column="19">else <block pos:line="786" pos:column="24">{
			<return pos:line="787" pos:column="25">return <expr><lit:literal type="number" pos:line="787" pos:column="32">0</lit:literal></expr>;</return>
		}</block></else></if>
	</case><case pos:line="789" pos:column="9">case <expr><name pos:line="789" pos:column="14">CHR</name></expr>:			<comment type="block" pos:line="789" pos:column="41">/* ordinary char: locate it fast */</comment>
		<expr_stmt><expr><name pos:line="790" pos:column="17">c</name> <op:operator pos:line="790" pos:column="19">=</op:operator> <op:operator pos:line="790" pos:column="21">*</op:operator><op:operator pos:line="790" pos:column="22">(</op:operator><name pos:line="790" pos:column="23">ap</name><op:operator pos:line="790" pos:column="25">+</op:operator><lit:literal type="number" pos:line="790" pos:column="26">1</lit:literal><op:operator pos:line="790" pos:column="27">)</op:operator></expr>;</expr_stmt>
		<while pos:line="791" pos:column="17">while <condition pos:line="791" pos:column="23">(<expr><op:operator pos:line="791" pos:column="24">(</op:operator><name pos:line="791" pos:column="25">lp</name> <op:operator pos:line="791" pos:column="28">&lt;</op:operator> <name pos:line="791" pos:column="30">endp</name><op:operator pos:line="791" pos:column="34">)</op:operator> <op:operator pos:line="791" pos:column="36">&amp;&amp;</op:operator> <op:operator pos:line="791" pos:column="39">(</op:operator><call><name><name pos:line="791" pos:column="40">ci</name><op:operator pos:line="791" pos:column="42">.</op:operator><name pos:line="791" pos:column="43">CharAt</name></name><argument_list pos:line="791" pos:column="49">(<argument><expr><name pos:line="791" pos:column="50">lp</name></expr></argument>)</argument_list></call> <op:operator pos:line="791" pos:column="54">!=</op:operator> <name pos:line="791" pos:column="57">c</name><op:operator pos:line="791" pos:column="58">)</op:operator></expr>)</condition>
			<expr_stmt><expr><name pos:line="792" pos:column="25">lp</name><op:operator pos:line="792" pos:column="27">++</op:operator></expr>;</expr_stmt></while>
		<if pos:line="793" pos:column="17">if <condition pos:line="793" pos:column="20">(<expr><name pos:line="793" pos:column="21">lp</name> <op:operator pos:line="793" pos:column="24">&gt;=</op:operator> <name pos:line="793" pos:column="27">endp</name></expr>)</condition><then pos:line="793" pos:column="32">	<comment type="block" pos:line="793" pos:column="33">/* if EOS, fail, else fall thru. */</comment>
			<return pos:line="794" pos:column="25">return <expr><lit:literal type="number" pos:line="794" pos:column="32">0</lit:literal></expr>;</return></then></if>
	</case><default pos:line="795" pos:column="9">default:			<comment type="block" pos:line="795" pos:column="41">/* regular matching all the way. */</comment>
		<while pos:line="796" pos:column="17">while <condition pos:line="796" pos:column="23">(<expr><name pos:line="796" pos:column="24">lp</name> <op:operator pos:line="796" pos:column="27">&lt;</op:operator> <name pos:line="796" pos:column="29">endp</name></expr>)</condition> <block pos:line="796" pos:column="35">{
			<expr_stmt><expr><name pos:line="797" pos:column="25">ep</name> <op:operator pos:line="797" pos:column="28">=</op:operator> <call><name pos:line="797" pos:column="30">PMatch</name><argument_list pos:line="797" pos:column="36">(<argument><expr><name pos:line="797" pos:column="37">ci</name></expr></argument>, <argument><expr><name pos:line="797" pos:column="41">lp</name></expr></argument>, <argument><expr><name pos:line="797" pos:column="45">endp</name></expr></argument>, <argument><expr><name pos:line="797" pos:column="51">ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if pos:line="798" pos:column="25">if <condition pos:line="798" pos:column="28">(<expr><name pos:line="798" pos:column="29">ep</name> <op:operator pos:line="798" pos:column="32">!=</op:operator> <name pos:line="798" pos:column="35">NOTFOUND</name></expr>)</condition><then pos:line="798" pos:column="44">
				<break pos:line="799" pos:column="33">break;</break></then></if>
			<expr_stmt><expr><name pos:line="800" pos:column="25">lp</name><op:operator pos:line="800" pos:column="27">++</op:operator></expr>;</expr_stmt>
		}</block></while>
		<break pos:line="802" pos:column="17">break;</break>
	</default><case pos:line="803" pos:column="9">case <expr><name pos:line="803" pos:column="14">END</name></expr>:			<comment type="block" pos:line="803" pos:column="41">/* munged automaton. fail always */</comment>
		<return pos:line="804" pos:column="17">return <expr><lit:literal type="number" pos:line="804" pos:column="24">0</lit:literal></expr>;</return>
	</case>}</block></switch>
	<if pos:line="806" pos:column="9">if <condition pos:line="806" pos:column="12">(<expr><name pos:line="806" pos:column="13">ep</name> <op:operator pos:line="806" pos:column="16">==</op:operator> <name pos:line="806" pos:column="19">NOTFOUND</name></expr>)</condition><then pos:line="806" pos:column="28">
		<return pos:line="807" pos:column="17">return <expr><lit:literal type="number" pos:line="807" pos:column="24">0</lit:literal></expr>;</return></then></if>

	<expr_stmt><expr><name><name pos:line="809" pos:column="9">bopat</name><index pos:line="809" pos:column="14">[<expr><lit:literal type="number" pos:line="809" pos:column="15">0</lit:literal></expr>]</index></name> <op:operator pos:line="809" pos:column="18">=</op:operator> <name pos:line="809" pos:column="20">lp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name pos:line="810" pos:column="9">eopat</name><index pos:line="810" pos:column="14">[<expr><lit:literal type="number" pos:line="810" pos:column="15">0</lit:literal></expr>]</index></name> <op:operator pos:line="810" pos:column="18">=</op:operator> <name pos:line="810" pos:column="20">ep</name></expr>;</expr_stmt>
	<return pos:line="811" pos:column="9">return <expr><lit:literal type="number" pos:line="811" pos:column="16">1</lit:literal></expr>;</return>
}</block></function>

<comment type="block" pos:line="814" pos:column="1">/*
 * PMatch: internal routine for the hard part
 *
 *  This code is partly snarfed from an early grep written by
 *  David Conroy. The backref and tag stuff, and various other
 *  innovations are by oz.
 *
 *  special case optimizations: (nfa[n], nfa[n+1])
 *      CLO ANY
 *          We KNOW .* will match everything upto the
 *          end of line. Thus, directly go to the end of
 *          line, without recursive PMatch calls. As in
 *          the other closure cases, the remaining pattern
 *          must be matched by moving backwards on the
 *          string recursively, to find a match for xy
 *          (x is ".*" and y is the remaining pattern)
 *          where the match satisfies the LONGEST match for
 *          x followed by a match for y.
 *      CLO CHR
 *          We can again scan the string forward for the
 *          single char and at the point of failure, we
 *          execute the remaining nfa recursively, same as
 *          above.
 *
 *  At the end of a successful match, bopat[n] and eopat[n]
 *  are set to the beginning and end of subpatterns matched
 *  by tagged expressions (n = 1 to 9).
 */</comment>

<function_decl><type><specifier pos:line="843" pos:column="1">extern</specifier> <name pos:line="843" pos:column="8">void</name></type> <name pos:line="843" pos:column="13">re_fail</name><parameter_list pos:line="843" pos:column="20">(<param><decl><type><name pos:line="843" pos:column="21">char</name> <type:modifier pos:line="843" pos:column="26">*</type:modifier></type></decl></param>,<param><decl><type><name pos:line="843" pos:column="28">char</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:define pos:line="845" pos:column="1">#<cpp:directive pos:line="845" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="845" pos:column="9">isinset</name><parameter_list pos:line="845" pos:column="16">(<param><type><name pos:line="845" pos:column="17">x</name></type></param>,<param><type><name pos:line="845" pos:column="19">y</name></type></param>)</parameter_list></cpp:macro>	<cpp:value pos:line="845" pos:column="25">((x)[((y)&amp;BLKIND)&gt;&gt;3] &amp; bitarr[(y)&amp;BITIND])</cpp:value></cpp:define>

<comment type="block" pos:line="847" pos:column="1">/*
 * skip values for CLO XXX to skip past the closure
 */</comment>

<cpp:define pos:line="851" pos:column="1">#<cpp:directive pos:line="851" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="851" pos:column="9">ANYSKIP</name></cpp:macro> <cpp:value pos:line="851" pos:column="17">2</cpp:value></cpp:define> 	<comment type="block" pos:line="851" pos:column="25">/* [CLO] ANY END          */</comment>
<cpp:define pos:line="852" pos:column="1">#<cpp:directive pos:line="852" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="852" pos:column="9">CHRSKIP</name></cpp:macro> <cpp:value pos:line="852" pos:column="17">3</cpp:value></cpp:define>	<comment type="block" pos:line="852" pos:column="25">/* [CLO] CHR chr END      */</comment>
<cpp:define pos:line="853" pos:column="1">#<cpp:directive pos:line="853" pos:column="2">define</cpp:directive> <cpp:macro><name pos:line="853" pos:column="9">CCLSKIP</name></cpp:macro> <cpp:value pos:line="853" pos:column="17">34</cpp:value></cpp:define>	<comment type="block" pos:line="853" pos:column="25">/* [CLO] CCL 32 bytes END */</comment>

<function><type><name pos:line="855" pos:column="1">int</name></type> <name><name pos:line="855" pos:column="5">RESearch</name><op:operator pos:line="855" pos:column="13">::</op:operator><name pos:line="855" pos:column="15">PMatch</name></name><parameter_list pos:line="855" pos:column="21">(<param><decl><type><name pos:line="855" pos:column="22">CharacterIndexer</name> <type:modifier pos:line="855" pos:column="39">&amp;</type:modifier></type><name pos:line="855" pos:column="40">ci</name></decl></param>, <param><decl><type><name pos:line="855" pos:column="44">int</name></type> <name pos:line="855" pos:column="48">lp</name></decl></param>, <param><decl><type><name pos:line="855" pos:column="52">int</name></type> <name pos:line="855" pos:column="56">endp</name></decl></param>, <param><decl><type><name pos:line="855" pos:column="62">char</name> <type:modifier pos:line="855" pos:column="67">*</type:modifier></type><name pos:line="855" pos:column="68">ap</name></decl></param>)</parameter_list> <block pos:line="855" pos:column="72">{
	<decl_stmt><decl><type><name pos:line="856" pos:column="9">int</name></type> <name pos:line="856" pos:column="13">op</name></decl><op:operator pos:line="856" pos:column="15">,</op:operator> <decl><type ref="prev"/><name pos:line="856" pos:column="17">c</name></decl><op:operator pos:line="856" pos:column="18">,</op:operator> <decl><type ref="prev"/><name pos:line="856" pos:column="20">n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="857" pos:column="9">int</name></type> <name pos:line="857" pos:column="13">e</name></decl>;</decl_stmt>		<comment type="block" pos:line="857" pos:column="25">/* extra pointer for CLO  */</comment>
	<decl_stmt><decl><type><name pos:line="858" pos:column="9">int</name></type> <name pos:line="858" pos:column="13">bp</name></decl>;</decl_stmt>		<comment type="block" pos:line="858" pos:column="25">/* beginning of subpat... */</comment>
	<decl_stmt><decl><type><name pos:line="859" pos:column="9">int</name></type> <name pos:line="859" pos:column="13">ep</name></decl>;</decl_stmt>		<comment type="block" pos:line="859" pos:column="25">/* ending of subpat...    */</comment>
	<decl_stmt><decl><type><name pos:line="860" pos:column="9">int</name></type> <name pos:line="860" pos:column="13">are</name></decl>;</decl_stmt>	<comment type="block" pos:line="860" pos:column="25">/* to save the line ptr.  */</comment>
	<decl_stmt><decl><type><name pos:line="861" pos:column="9">int</name></type> <name pos:line="861" pos:column="13">llp</name></decl>;</decl_stmt>	<comment type="block" pos:line="861" pos:column="25">/* lazy lp for LCLO       */</comment>

	<while pos:line="863" pos:column="9">while <condition pos:line="863" pos:column="15">(<expr><op:operator pos:line="863" pos:column="16">(</op:operator><name pos:line="863" pos:column="17">op</name> <op:operator pos:line="863" pos:column="20">=</op:operator> <op:operator pos:line="863" pos:column="22">*</op:operator><name pos:line="863" pos:column="23">ap</name><op:operator pos:line="863" pos:column="25">++</op:operator><op:operator pos:line="863" pos:column="27">)</op:operator> <op:operator pos:line="863" pos:column="29">!=</op:operator> <name pos:line="863" pos:column="32">END</name></expr>)</condition>
		<switch pos:line="864" pos:column="17">switch <condition pos:line="864" pos:column="24">(<expr><name pos:line="864" pos:column="25">op</name></expr>)</condition> <block pos:line="864" pos:column="29">{

		<case pos:line="866" pos:column="17">case <expr><name pos:line="866" pos:column="22">CHR</name></expr>:
			<if pos:line="867" pos:column="25">if <condition pos:line="867" pos:column="28">(<expr><call><name><name pos:line="867" pos:column="29">ci</name><op:operator pos:line="867" pos:column="31">.</op:operator><name pos:line="867" pos:column="32">CharAt</name></name><argument_list pos:line="867" pos:column="38">(<argument><expr><name pos:line="867" pos:column="39">lp</name><op:operator pos:line="867" pos:column="41">++</op:operator></expr></argument>)</argument_list></call> <op:operator pos:line="867" pos:column="45">!=</op:operator> <op:operator pos:line="867" pos:column="48">*</op:operator><name pos:line="867" pos:column="49">ap</name><op:operator pos:line="867" pos:column="51">++</op:operator></expr>)</condition><then pos:line="867" pos:column="54">
				<return pos:line="868" pos:column="33">return <expr><name pos:line="868" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="869" pos:column="25">break;</break>
		</case><case pos:line="870" pos:column="17">case <expr><name pos:line="870" pos:column="22">ANY</name></expr>:
			<if pos:line="871" pos:column="25">if <condition pos:line="871" pos:column="28">(<expr><name pos:line="871" pos:column="29">lp</name><op:operator pos:line="871" pos:column="31">++</op:operator> <op:operator pos:line="871" pos:column="34">&gt;=</op:operator> <name pos:line="871" pos:column="37">endp</name></expr>)</condition><then pos:line="871" pos:column="42">
				<return pos:line="872" pos:column="33">return <expr><name pos:line="872" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="873" pos:column="25">break;</break>
		</case><case pos:line="874" pos:column="17">case <expr><name pos:line="874" pos:column="22">CCL</name></expr>:
			<if pos:line="875" pos:column="25">if <condition pos:line="875" pos:column="28">(<expr><name pos:line="875" pos:column="29">lp</name> <op:operator pos:line="875" pos:column="32">&gt;=</op:operator> <name pos:line="875" pos:column="35">endp</name></expr>)</condition><then pos:line="875" pos:column="40">
				<return pos:line="876" pos:column="33">return <expr><name pos:line="876" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<expr_stmt><expr><name pos:line="877" pos:column="25">c</name> <op:operator pos:line="877" pos:column="27">=</op:operator> <call><name><name pos:line="877" pos:column="29">ci</name><op:operator pos:line="877" pos:column="31">.</op:operator><name pos:line="877" pos:column="32">CharAt</name></name><argument_list pos:line="877" pos:column="38">(<argument><expr><name pos:line="877" pos:column="39">lp</name><op:operator pos:line="877" pos:column="41">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if pos:line="878" pos:column="25">if <condition pos:line="878" pos:column="28">(<expr><op:operator pos:line="878" pos:column="29">!</op:operator><call><name pos:line="878" pos:column="30">isinset</name><argument_list pos:line="878" pos:column="37">(<argument><expr><name pos:line="878" pos:column="38">ap</name></expr></argument>,<argument><expr><name pos:line="878" pos:column="41">c</name></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="878" pos:column="44">
				<return pos:line="879" pos:column="33">return <expr><name pos:line="879" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<expr_stmt><expr><name pos:line="880" pos:column="25">ap</name> <op:operator pos:line="880" pos:column="28">+=</op:operator> <name pos:line="880" pos:column="31">BITBLK</name></expr>;</expr_stmt>
			<break pos:line="881" pos:column="25">break;</break>
		</case><case pos:line="882" pos:column="17">case <expr><name pos:line="882" pos:column="22">BOL</name></expr>:
			<if pos:line="883" pos:column="25">if <condition pos:line="883" pos:column="28">(<expr><name pos:line="883" pos:column="29">lp</name> <op:operator pos:line="883" pos:column="32">!=</op:operator> <name pos:line="883" pos:column="35">bol</name></expr>)</condition><then pos:line="883" pos:column="39">
				<return pos:line="884" pos:column="33">return <expr><name pos:line="884" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="885" pos:column="25">break;</break>
		</case><case pos:line="886" pos:column="17">case <expr><name pos:line="886" pos:column="22">EOL</name></expr>:
			<if pos:line="887" pos:column="25">if <condition pos:line="887" pos:column="28">(<expr><name pos:line="887" pos:column="29">lp</name> <op:operator pos:line="887" pos:column="32">&lt;</op:operator> <name pos:line="887" pos:column="34">endp</name></expr>)</condition><then pos:line="887" pos:column="39">
				<return pos:line="888" pos:column="33">return <expr><name pos:line="888" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="889" pos:column="25">break;</break>
		</case><case pos:line="890" pos:column="17">case <expr><name pos:line="890" pos:column="22">BOT</name></expr>:
			<expr_stmt><expr><name><name pos:line="891" pos:column="25">bopat</name><index pos:line="891" pos:column="30">[<expr><call><name><name pos:line="891" pos:column="31">static_cast</name><argument_list pos:line="891" pos:column="42">&lt;<argument><expr><name pos:line="891" pos:column="43">int</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="891" pos:column="47">(<argument><expr><op:operator pos:line="891" pos:column="48">*</op:operator><name pos:line="891" pos:column="49">ap</name><op:operator pos:line="891" pos:column="51">++</op:operator></expr></argument>)</argument_list></call></expr>]</index></name> <op:operator pos:line="891" pos:column="56">=</op:operator> <name pos:line="891" pos:column="58">lp</name></expr>;</expr_stmt>
			<break pos:line="892" pos:column="25">break;</break>
		</case><case pos:line="893" pos:column="17">case <expr><name pos:line="893" pos:column="22">EOT</name></expr>:
			<expr_stmt><expr><name><name pos:line="894" pos:column="25">eopat</name><index pos:line="894" pos:column="30">[<expr><call><name><name pos:line="894" pos:column="31">static_cast</name><argument_list pos:line="894" pos:column="42">&lt;<argument><expr><name pos:line="894" pos:column="43">int</name></expr></argument>&gt;</argument_list></name><argument_list pos:line="894" pos:column="47">(<argument><expr><op:operator pos:line="894" pos:column="48">*</op:operator><name pos:line="894" pos:column="49">ap</name><op:operator pos:line="894" pos:column="51">++</op:operator></expr></argument>)</argument_list></call></expr>]</index></name> <op:operator pos:line="894" pos:column="56">=</op:operator> <name pos:line="894" pos:column="58">lp</name></expr>;</expr_stmt>
			<break pos:line="895" pos:column="25">break;</break>
		</case><case pos:line="896" pos:column="17">case <expr><name pos:line="896" pos:column="22">BOW</name></expr>:
			<if pos:line="897" pos:column="25">if <condition pos:line="897" pos:column="28">(<expr><op:operator pos:line="897" pos:column="29">(</op:operator><name pos:line="897" pos:column="30">lp</name><op:operator pos:line="897" pos:column="32">!=</op:operator><name pos:line="897" pos:column="34">bol</name> <op:operator pos:line="897" pos:column="38">&amp;&amp;</op:operator> <call><name pos:line="897" pos:column="41">iswordc</name><argument_list pos:line="897" pos:column="48">(<argument><expr><call><name><name pos:line="897" pos:column="49">ci</name><op:operator pos:line="897" pos:column="51">.</op:operator><name pos:line="897" pos:column="52">CharAt</name></name><argument_list pos:line="897" pos:column="58">(<argument><expr><name pos:line="897" pos:column="59">lp</name><op:operator pos:line="897" pos:column="61">-</op:operator><lit:literal type="number" pos:line="897" pos:column="62">1</lit:literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><op:operator pos:line="897" pos:column="65">)</op:operator> <op:operator pos:line="897" pos:column="67">||</op:operator> <op:operator pos:line="897" pos:column="70">!</op:operator><call><name pos:line="897" pos:column="71">iswordc</name><argument_list pos:line="897" pos:column="78">(<argument><expr><call><name><name pos:line="897" pos:column="79">ci</name><op:operator pos:line="897" pos:column="81">.</op:operator><name pos:line="897" pos:column="82">CharAt</name></name><argument_list pos:line="897" pos:column="88">(<argument><expr><name pos:line="897" pos:column="89">lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="897" pos:column="94">
				<return pos:line="898" pos:column="33">return <expr><name pos:line="898" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="899" pos:column="25">break;</break>
		</case><case pos:line="900" pos:column="17">case <expr><name pos:line="900" pos:column="22">EOW</name></expr>:
			<if pos:line="901" pos:column="25">if <condition pos:line="901" pos:column="28">(<expr><name pos:line="901" pos:column="29">lp</name><op:operator pos:line="901" pos:column="31">==</op:operator><name pos:line="901" pos:column="33">bol</name> <op:operator pos:line="901" pos:column="37">||</op:operator> <op:operator pos:line="901" pos:column="40">!</op:operator><call><name pos:line="901" pos:column="41">iswordc</name><argument_list pos:line="901" pos:column="48">(<argument><expr><call><name><name pos:line="901" pos:column="49">ci</name><op:operator pos:line="901" pos:column="51">.</op:operator><name pos:line="901" pos:column="52">CharAt</name></name><argument_list pos:line="901" pos:column="58">(<argument><expr><name pos:line="901" pos:column="59">lp</name><op:operator pos:line="901" pos:column="61">-</op:operator><lit:literal type="number" pos:line="901" pos:column="62">1</lit:literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <op:operator pos:line="901" pos:column="66">||</op:operator> <call><name pos:line="901" pos:column="69">iswordc</name><argument_list pos:line="901" pos:column="76">(<argument><expr><call><name><name pos:line="901" pos:column="77">ci</name><op:operator pos:line="901" pos:column="79">.</op:operator><name pos:line="901" pos:column="80">CharAt</name></name><argument_list pos:line="901" pos:column="86">(<argument><expr><name pos:line="901" pos:column="87">lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="901" pos:column="92">
				<return pos:line="902" pos:column="33">return <expr><name pos:line="902" pos:column="40">NOTFOUND</name></expr>;</return></then></if>
			<break pos:line="903" pos:column="25">break;</break>
		</case><case pos:line="904" pos:column="17">case <expr><name pos:line="904" pos:column="22">REF</name></expr>:
			<expr_stmt><expr><name pos:line="905" pos:column="25">n</name> <op:operator pos:line="905" pos:column="27">=</op:operator> <op:operator pos:line="905" pos:column="29">*</op:operator><name pos:line="905" pos:column="30">ap</name><op:operator pos:line="905" pos:column="32">++</op:operator></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="906" pos:column="25">bp</name> <op:operator pos:line="906" pos:column="28">=</op:operator> <name><name pos:line="906" pos:column="30">bopat</name><index pos:line="906" pos:column="35">[<expr><name pos:line="906" pos:column="36">n</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="907" pos:column="25">ep</name> <op:operator pos:line="907" pos:column="28">=</op:operator> <name><name pos:line="907" pos:column="30">eopat</name><index pos:line="907" pos:column="35">[<expr><name pos:line="907" pos:column="36">n</name></expr>]</index></name></expr>;</expr_stmt>
			<while pos:line="908" pos:column="25">while <condition pos:line="908" pos:column="31">(<expr><name pos:line="908" pos:column="32">bp</name> <op:operator pos:line="908" pos:column="35">&lt;</op:operator> <name pos:line="908" pos:column="37">ep</name></expr>)</condition>
				<if pos:line="909" pos:column="33">if <condition pos:line="909" pos:column="36">(<expr><call><name><name pos:line="909" pos:column="37">ci</name><op:operator pos:line="909" pos:column="39">.</op:operator><name pos:line="909" pos:column="40">CharAt</name></name><argument_list pos:line="909" pos:column="46">(<argument><expr><name pos:line="909" pos:column="47">bp</name><op:operator pos:line="909" pos:column="49">++</op:operator></expr></argument>)</argument_list></call> <op:operator pos:line="909" pos:column="53">!=</op:operator> <call><name><name pos:line="909" pos:column="56">ci</name><op:operator pos:line="909" pos:column="58">.</op:operator><name pos:line="909" pos:column="59">CharAt</name></name><argument_list pos:line="909" pos:column="65">(<argument><expr><name pos:line="909" pos:column="66">lp</name><op:operator pos:line="909" pos:column="68">++</op:operator></expr></argument>)</argument_list></call></expr>)</condition><then pos:line="909" pos:column="72">
					<return pos:line="910" pos:column="41">return <expr><name pos:line="910" pos:column="48">NOTFOUND</name></expr>;</return></then></if></while>
			<break pos:line="911" pos:column="25">break;</break>
		</case><case pos:line="912" pos:column="17">case <expr><name pos:line="912" pos:column="22">LCLO</name></expr>:
		</case><case pos:line="913" pos:column="17">case <expr><name pos:line="913" pos:column="22">CLQ</name></expr>:
		</case><case pos:line="914" pos:column="17">case <expr><name pos:line="914" pos:column="22">CLO</name></expr>:
			<expr_stmt><expr><name pos:line="915" pos:column="25">are</name> <op:operator pos:line="915" pos:column="29">=</op:operator> <name pos:line="915" pos:column="31">lp</name></expr>;</expr_stmt>
			<switch pos:line="916" pos:column="25">switch <condition pos:line="916" pos:column="32">(<expr><op:operator pos:line="916" pos:column="33">*</op:operator><name pos:line="916" pos:column="34">ap</name></expr>)</condition> <block pos:line="916" pos:column="38">{

			<case pos:line="918" pos:column="25">case <expr><name pos:line="918" pos:column="30">ANY</name></expr>:
				<if pos:line="919" pos:column="33">if <condition pos:line="919" pos:column="36">(<expr><name pos:line="919" pos:column="37">op</name> <op:operator pos:line="919" pos:column="40">==</op:operator> <name pos:line="919" pos:column="43">CLO</name> <op:operator pos:line="919" pos:column="47">||</op:operator> <name pos:line="919" pos:column="50">op</name> <op:operator pos:line="919" pos:column="53">==</op:operator> <name pos:line="919" pos:column="56">LCLO</name></expr>)</condition><then pos:line="919" pos:column="61">
					<while pos:line="920" pos:column="41">while <condition pos:line="920" pos:column="47">(<expr><name pos:line="920" pos:column="48">lp</name> <op:operator pos:line="920" pos:column="51">&lt;</op:operator> <name pos:line="920" pos:column="53">endp</name></expr>)</condition>
						<expr_stmt><expr><name pos:line="921" pos:column="49">lp</name><op:operator pos:line="921" pos:column="51">++</op:operator></expr>;</expr_stmt></while></then>
				<else pos:line="922" pos:column="33">else <if pos:line="922" pos:column="38">if <condition pos:line="922" pos:column="41">(<expr><name pos:line="922" pos:column="42">lp</name> <op:operator pos:line="922" pos:column="45">&lt;</op:operator> <name pos:line="922" pos:column="47">endp</name></expr>)</condition><then pos:line="922" pos:column="52">
					<expr_stmt><expr><name pos:line="923" pos:column="41">lp</name><op:operator pos:line="923" pos:column="43">++</op:operator></expr>;</expr_stmt></then></if></else></if>

				<expr_stmt><expr><name pos:line="925" pos:column="33">n</name> <op:operator pos:line="925" pos:column="35">=</op:operator> <name pos:line="925" pos:column="37">ANYSKIP</name></expr>;</expr_stmt>
				<break pos:line="926" pos:column="33">break;</break>
			</case><case pos:line="927" pos:column="25">case <expr><name pos:line="927" pos:column="30">CHR</name></expr>:
				<expr_stmt><expr><name pos:line="928" pos:column="33">c</name> <op:operator pos:line="928" pos:column="35">=</op:operator> <op:operator pos:line="928" pos:column="37">*</op:operator><op:operator pos:line="928" pos:column="38">(</op:operator><name pos:line="928" pos:column="39">ap</name><op:operator pos:line="928" pos:column="41">+</op:operator><lit:literal type="number" pos:line="928" pos:column="42">1</lit:literal><op:operator pos:line="928" pos:column="43">)</op:operator></expr>;</expr_stmt>
				<if pos:line="929" pos:column="33">if <condition pos:line="929" pos:column="36">(<expr><name pos:line="929" pos:column="37">op</name> <op:operator pos:line="929" pos:column="40">==</op:operator> <name pos:line="929" pos:column="43">CLO</name> <op:operator pos:line="929" pos:column="47">||</op:operator> <name pos:line="929" pos:column="50">op</name> <op:operator pos:line="929" pos:column="53">==</op:operator> <name pos:line="929" pos:column="56">LCLO</name></expr>)</condition><then pos:line="929" pos:column="61">
					<while pos:line="930" pos:column="41">while <condition pos:line="930" pos:column="47">(<expr><op:operator pos:line="930" pos:column="48">(</op:operator><name pos:line="930" pos:column="49">lp</name> <op:operator pos:line="930" pos:column="52">&lt;</op:operator> <name pos:line="930" pos:column="54">endp</name><op:operator pos:line="930" pos:column="58">)</op:operator> <op:operator pos:line="930" pos:column="60">&amp;&amp;</op:operator> <op:operator pos:line="930" pos:column="63">(</op:operator><name pos:line="930" pos:column="64">c</name> <op:operator pos:line="930" pos:column="66">==</op:operator> <call><name><name pos:line="930" pos:column="69">ci</name><op:operator pos:line="930" pos:column="71">.</op:operator><name pos:line="930" pos:column="72">CharAt</name></name><argument_list pos:line="930" pos:column="78">(<argument><expr><name pos:line="930" pos:column="79">lp</name></expr></argument>)</argument_list></call><op:operator pos:line="930" pos:column="82">)</op:operator></expr>)</condition>
						<expr_stmt><expr><name pos:line="931" pos:column="49">lp</name><op:operator pos:line="931" pos:column="51">++</op:operator></expr>;</expr_stmt></while></then>
				<else pos:line="932" pos:column="33">else <if pos:line="932" pos:column="38">if <condition pos:line="932" pos:column="41">(<expr><op:operator pos:line="932" pos:column="42">(</op:operator><name pos:line="932" pos:column="43">lp</name> <op:operator pos:line="932" pos:column="46">&lt;</op:operator> <name pos:line="932" pos:column="48">endp</name><op:operator pos:line="932" pos:column="52">)</op:operator> <op:operator pos:line="932" pos:column="54">&amp;&amp;</op:operator> <op:operator pos:line="932" pos:column="57">(</op:operator><name pos:line="932" pos:column="58">c</name> <op:operator pos:line="932" pos:column="60">==</op:operator> <call><name><name pos:line="932" pos:column="63">ci</name><op:operator pos:line="932" pos:column="65">.</op:operator><name pos:line="932" pos:column="66">CharAt</name></name><argument_list pos:line="932" pos:column="72">(<argument><expr><name pos:line="932" pos:column="73">lp</name></expr></argument>)</argument_list></call><op:operator pos:line="932" pos:column="76">)</op:operator></expr>)</condition><then pos:line="932" pos:column="78">
					<expr_stmt><expr><name pos:line="933" pos:column="41">lp</name><op:operator pos:line="933" pos:column="43">++</op:operator></expr>;</expr_stmt></then></if></else></if>
				<expr_stmt><expr><name pos:line="934" pos:column="33">n</name> <op:operator pos:line="934" pos:column="35">=</op:operator> <name pos:line="934" pos:column="37">CHRSKIP</name></expr>;</expr_stmt>
				<break pos:line="935" pos:column="33">break;</break>
			</case><case pos:line="936" pos:column="25">case <expr><name pos:line="936" pos:column="30">CCL</name></expr>:
				<while pos:line="937" pos:column="33">while <condition pos:line="937" pos:column="39">(<expr><op:operator pos:line="937" pos:column="40">(</op:operator><name pos:line="937" pos:column="41">lp</name> <op:operator pos:line="937" pos:column="44">&lt;</op:operator> <name pos:line="937" pos:column="46">endp</name><op:operator pos:line="937" pos:column="50">)</op:operator> <op:operator pos:line="937" pos:column="52">&amp;&amp;</op:operator> <call><name pos:line="937" pos:column="55">isinset</name><argument_list pos:line="937" pos:column="62">(<argument><expr><name pos:line="937" pos:column="63">ap</name><op:operator pos:line="937" pos:column="65">+</op:operator><lit:literal type="number" pos:line="937" pos:column="66">1</lit:literal></expr></argument>,<argument><expr><call><name><name pos:line="937" pos:column="68">ci</name><op:operator pos:line="937" pos:column="70">.</op:operator><name pos:line="937" pos:column="71">CharAt</name></name><argument_list pos:line="937" pos:column="77">(<argument><expr><name pos:line="937" pos:column="78">lp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
					<expr_stmt><expr><name pos:line="938" pos:column="41">lp</name><op:operator pos:line="938" pos:column="43">++</op:operator></expr>;</expr_stmt></while>
				<expr_stmt><expr><name pos:line="939" pos:column="33">n</name> <op:operator pos:line="939" pos:column="35">=</op:operator> <name pos:line="939" pos:column="37">CCLSKIP</name></expr>;</expr_stmt>
				<break pos:line="940" pos:column="33">break;</break>
			</case><default pos:line="941" pos:column="25">default:
				<expr_stmt><expr><name pos:line="942" pos:column="33">failure</name> <op:operator pos:line="942" pos:column="41">=</op:operator> <lit:literal type="boolean" pos:line="942" pos:column="43">true</lit:literal></expr>;</expr_stmt>
				<comment type="line" pos:line="943" pos:column="33">//re_fail("closure: bad nfa.", *ap);</comment>
				<return pos:line="944" pos:column="33">return <expr><name pos:line="944" pos:column="40">NOTFOUND</name></expr>;</return>
			</default>}</block></switch>
			<expr_stmt><expr><name pos:line="946" pos:column="25">ap</name> <op:operator pos:line="946" pos:column="28">+=</op:operator> <name pos:line="946" pos:column="31">n</name></expr>;</expr_stmt>

			<expr_stmt><expr><name pos:line="948" pos:column="25">llp</name> <op:operator pos:line="948" pos:column="29">=</op:operator> <name pos:line="948" pos:column="31">lp</name></expr>;</expr_stmt>
			<expr_stmt><expr><name pos:line="949" pos:column="25">e</name> <op:operator pos:line="949" pos:column="27">=</op:operator> <name pos:line="949" pos:column="29">NOTFOUND</name></expr>;</expr_stmt>
			<while pos:line="950" pos:column="25">while <condition pos:line="950" pos:column="31">(<expr><name pos:line="950" pos:column="32">llp</name> <op:operator pos:line="950" pos:column="36">&gt;=</op:operator> <name pos:line="950" pos:column="39">are</name></expr>)</condition> <block pos:line="950" pos:column="44">{
				<decl_stmt><decl><type><name pos:line="951" pos:column="33">int</name></type> <name pos:line="951" pos:column="37">q</name></decl>;</decl_stmt>
				<if pos:line="952" pos:column="33">if <condition pos:line="952" pos:column="36">(<expr><op:operator pos:line="952" pos:column="37">(</op:operator><name pos:line="952" pos:column="38">q</name> <op:operator pos:line="952" pos:column="40">=</op:operator> <call><name pos:line="952" pos:column="42">PMatch</name><argument_list pos:line="952" pos:column="48">(<argument><expr><name pos:line="952" pos:column="49">ci</name></expr></argument>, <argument><expr><name pos:line="952" pos:column="53">llp</name></expr></argument>, <argument><expr><name pos:line="952" pos:column="58">endp</name></expr></argument>, <argument><expr><name pos:line="952" pos:column="64">ap</name></expr></argument>)</argument_list></call><op:operator pos:line="952" pos:column="67">)</op:operator> <op:operator pos:line="952" pos:column="69">!=</op:operator> <name pos:line="952" pos:column="72">NOTFOUND</name></expr>)</condition><then pos:line="952" pos:column="81"> <block pos:line="952" pos:column="82">{
					<expr_stmt><expr><name pos:line="953" pos:column="41">e</name> <op:operator pos:line="953" pos:column="43">=</op:operator> <name pos:line="953" pos:column="45">q</name></expr>;</expr_stmt>
					<expr_stmt><expr><name pos:line="954" pos:column="41">lp</name> <op:operator pos:line="954" pos:column="44">=</op:operator> <name pos:line="954" pos:column="46">llp</name></expr>;</expr_stmt>
					<if pos:line="955" pos:column="41">if <condition pos:line="955" pos:column="44">(<expr><name pos:line="955" pos:column="45">op</name> <op:operator pos:line="955" pos:column="48">!=</op:operator> <name pos:line="955" pos:column="51">LCLO</name></expr>)</condition><then pos:line="955" pos:column="56"> <return pos:line="955" pos:column="57">return <expr><name pos:line="955" pos:column="64">e</name></expr>;</return></then></if>
				}</block></then></if>
				<if pos:line="957" pos:column="33">if <condition pos:line="957" pos:column="36">(<expr><op:operator pos:line="957" pos:column="37">*</op:operator><name pos:line="957" pos:column="38">ap</name> <op:operator pos:line="957" pos:column="41">==</op:operator> <name pos:line="957" pos:column="44">END</name></expr>)</condition><then pos:line="957" pos:column="48"> <return pos:line="957" pos:column="49">return <expr><name pos:line="957" pos:column="56">e</name></expr>;</return></then></if>
				<expr_stmt><expr><op:operator pos:line="958" pos:column="33">--</op:operator><name pos:line="958" pos:column="35">llp</name></expr>;</expr_stmt>
			}</block></while>
			<if pos:line="960" pos:column="25">if <condition pos:line="960" pos:column="28">(<expr><op:operator pos:line="960" pos:column="29">*</op:operator><name pos:line="960" pos:column="30">ap</name> <op:operator pos:line="960" pos:column="33">==</op:operator> <name pos:line="960" pos:column="36">EOT</name></expr>)</condition><then pos:line="960" pos:column="40">
				<expr_stmt><expr><call><name pos:line="961" pos:column="33">PMatch</name><argument_list pos:line="961" pos:column="39">(<argument><expr><name pos:line="961" pos:column="40">ci</name></expr></argument>, <argument><expr><name pos:line="961" pos:column="44">lp</name></expr></argument>, <argument><expr><name pos:line="961" pos:column="48">endp</name></expr></argument>, <argument><expr><name pos:line="961" pos:column="54">ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
			<return pos:line="962" pos:column="25">return <expr><name pos:line="962" pos:column="32">e</name></expr>;</return>
		</case><default pos:line="963" pos:column="17">default:
			<comment type="line" pos:line="964" pos:column="25">//re_fail("RESearch::Execute: bad nfa.", static_cast&lt;char&gt;(op));</comment>
			<return pos:line="965" pos:column="25">return <expr><name pos:line="965" pos:column="32">NOTFOUND</name></expr>;</return>
		</default>}</block></switch></while>
	<return pos:line="967" pos:column="9">return <expr><name pos:line="967" pos:column="16">lp</name></expr>;</return>
}</block></function>

<comment type="block" pos:line="970" pos:column="1">/*
 * RESearch::Substitute:
 *  substitute the matched portions of the src in dst.
 *
 *  &amp;    substitute the entire matched pattern.
 *
 *  \digit  substitute a subpattern, with the given tag number.
 *      Tags are numbered from 1 to 9. If the particular
 *      tagged subpattern does not exist, null is substituted.
 */</comment>
<function><type><name pos:line="980" pos:column="1">int</name></type> <name><name pos:line="980" pos:column="5">RESearch</name><op:operator pos:line="980" pos:column="13">::</op:operator><name pos:line="980" pos:column="15">Substitute</name></name><parameter_list pos:line="980" pos:column="25">(<param><decl><type><name pos:line="980" pos:column="26">CharacterIndexer</name> <type:modifier pos:line="980" pos:column="43">&amp;</type:modifier></type><name pos:line="980" pos:column="44">ci</name></decl></param>, <param><decl><type><name pos:line="980" pos:column="48">char</name> <type:modifier pos:line="980" pos:column="53">*</type:modifier></type><name pos:line="980" pos:column="54">src</name></decl></param>, <param><decl><type><name pos:line="980" pos:column="59">char</name> <type:modifier pos:line="980" pos:column="64">*</type:modifier></type><name pos:line="980" pos:column="65">dst</name></decl></param>)</parameter_list> <block pos:line="980" pos:column="70">{
	<decl_stmt><decl><type><name pos:line="981" pos:column="9">unsigned</name> <name pos:line="981" pos:column="18">char</name></type> <name pos:line="981" pos:column="23">c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="982" pos:column="9">int</name></type>  <name pos:line="982" pos:column="14">pin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="983" pos:column="9">int</name></type> <name pos:line="983" pos:column="13">bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name pos:line="984" pos:column="9">int</name></type> <name pos:line="984" pos:column="13">ep</name></decl>;</decl_stmt>

	<if pos:line="986" pos:column="9">if <condition pos:line="986" pos:column="12">(<expr><op:operator pos:line="986" pos:column="13">!</op:operator><op:operator pos:line="986" pos:column="14">*</op:operator><name pos:line="986" pos:column="15">src</name> <op:operator pos:line="986" pos:column="19">||</op:operator> <op:operator pos:line="986" pos:column="22">!</op:operator><name><name pos:line="986" pos:column="23">bopat</name><index pos:line="986" pos:column="28">[<expr><lit:literal type="number" pos:line="986" pos:column="29">0</lit:literal></expr>]</index></name></expr>)</condition><then pos:line="986" pos:column="32">
		<return pos:line="987" pos:column="17">return <expr><lit:literal type="number" pos:line="987" pos:column="24">0</lit:literal></expr>;</return></then></if>

	<while pos:line="989" pos:column="9">while <condition pos:line="989" pos:column="15">(<expr><op:operator pos:line="989" pos:column="16">(</op:operator><name pos:line="989" pos:column="17">c</name> <op:operator pos:line="989" pos:column="19">=</op:operator> <op:operator pos:line="989" pos:column="21">*</op:operator><name pos:line="989" pos:column="22">src</name><op:operator pos:line="989" pos:column="25">++</op:operator><op:operator pos:line="989" pos:column="27">)</op:operator> <op:operator pos:line="989" pos:column="29">!=</op:operator> <lit:literal type="number" pos:line="989" pos:column="32">0</lit:literal></expr>)</condition> <block pos:line="989" pos:column="35">{
		<switch pos:line="990" pos:column="17">switch <condition pos:line="990" pos:column="24">(<expr><name pos:line="990" pos:column="25">c</name></expr>)</condition> <block pos:line="990" pos:column="28">{

		<case pos:line="992" pos:column="17">case <expr><lit:literal type="char" pos:line="992" pos:column="22">'&amp;'</lit:literal></expr>:
			<expr_stmt><expr><name pos:line="993" pos:column="25">pin</name> <op:operator pos:line="993" pos:column="29">=</op:operator> <lit:literal type="number" pos:line="993" pos:column="31">0</lit:literal></expr>;</expr_stmt>
			<break pos:line="994" pos:column="25">break;</break>

		</case><case pos:line="996" pos:column="17">case <expr><lit:literal type="char" pos:line="996" pos:column="22">'\\'</lit:literal></expr>:
			<expr_stmt><expr><name pos:line="997" pos:column="25">c</name> <op:operator pos:line="997" pos:column="27">=</op:operator> <op:operator pos:line="997" pos:column="29">*</op:operator><name pos:line="997" pos:column="30">src</name><op:operator pos:line="997" pos:column="33">++</op:operator></expr>;</expr_stmt>
			<if pos:line="998" pos:column="25">if <condition pos:line="998" pos:column="28">(<expr><name pos:line="998" pos:column="29">c</name> <op:operator pos:line="998" pos:column="31">&gt;=</op:operator> <lit:literal type="char" pos:line="998" pos:column="34">'0'</lit:literal> <op:operator pos:line="998" pos:column="38">&amp;&amp;</op:operator> <name pos:line="998" pos:column="41">c</name> <op:operator pos:line="998" pos:column="43">&lt;=</op:operator> <lit:literal type="char" pos:line="998" pos:column="46">'9'</lit:literal></expr>)</condition><then pos:line="998" pos:column="50"> <block pos:line="998" pos:column="51">{
				<expr_stmt><expr><name pos:line="999" pos:column="33">pin</name> <op:operator pos:line="999" pos:column="37">=</op:operator> <name pos:line="999" pos:column="39">c</name> <op:operator pos:line="999" pos:column="41">-</op:operator> <lit:literal type="char" pos:line="999" pos:column="43">'0'</lit:literal></expr>;</expr_stmt>
				<break pos:line="1000" pos:column="33">break;</break>
			}</block></then></if>

		</case><default pos:line="1003" pos:column="17">default:
			<expr_stmt><expr><op:operator pos:line="1004" pos:column="25">*</op:operator><name pos:line="1004" pos:column="26">dst</name><op:operator pos:line="1004" pos:column="29">++</op:operator> <op:operator pos:line="1004" pos:column="32">=</op:operator> <name pos:line="1004" pos:column="34">c</name></expr>;</expr_stmt>
			<continue pos:line="1005" pos:column="25">continue;</continue>
		</default>}</block></switch>

		<if pos:line="1008" pos:column="17">if <condition pos:line="1008" pos:column="20">(<expr><op:operator pos:line="1008" pos:column="21">(</op:operator><name pos:line="1008" pos:column="22">bp</name> <op:operator pos:line="1008" pos:column="25">=</op:operator> <name><name pos:line="1008" pos:column="27">bopat</name><index pos:line="1008" pos:column="32">[<expr><name pos:line="1008" pos:column="33">pin</name></expr>]</index></name><op:operator pos:line="1008" pos:column="37">)</op:operator> <op:operator pos:line="1008" pos:column="39">!=</op:operator> <lit:literal type="number" pos:line="1008" pos:column="42">0</lit:literal> <op:operator pos:line="1008" pos:column="44">&amp;&amp;</op:operator> <op:operator pos:line="1008" pos:column="47">(</op:operator><name pos:line="1008" pos:column="48">ep</name> <op:operator pos:line="1008" pos:column="51">=</op:operator> <name><name pos:line="1008" pos:column="53">eopat</name><index pos:line="1008" pos:column="58">[<expr><name pos:line="1008" pos:column="59">pin</name></expr>]</index></name><op:operator pos:line="1008" pos:column="63">)</op:operator> <op:operator pos:line="1008" pos:column="65">!=</op:operator> <lit:literal type="number" pos:line="1008" pos:column="68">0</lit:literal></expr>)</condition><then pos:line="1008" pos:column="70"> <block pos:line="1008" pos:column="71">{
			<while pos:line="1009" pos:column="25">while <condition pos:line="1009" pos:column="31">(<expr><call><name><name pos:line="1009" pos:column="32">ci</name><op:operator pos:line="1009" pos:column="34">.</op:operator><name pos:line="1009" pos:column="35">CharAt</name></name><argument_list pos:line="1009" pos:column="41">(<argument><expr><name pos:line="1009" pos:column="42">bp</name></expr></argument>)</argument_list></call> <op:operator pos:line="1009" pos:column="46">&amp;&amp;</op:operator> <name pos:line="1009" pos:column="49">bp</name> <op:operator pos:line="1009" pos:column="52">&lt;</op:operator> <name pos:line="1009" pos:column="54">ep</name></expr>)</condition>
				<expr_stmt><expr><op:operator pos:line="1010" pos:column="33">*</op:operator><name pos:line="1010" pos:column="34">dst</name><op:operator pos:line="1010" pos:column="37">++</op:operator> <op:operator pos:line="1010" pos:column="40">=</op:operator> <call><name><name pos:line="1010" pos:column="42">ci</name><op:operator pos:line="1010" pos:column="44">.</op:operator><name pos:line="1010" pos:column="45">CharAt</name></name><argument_list pos:line="1010" pos:column="51">(<argument><expr><name pos:line="1010" pos:column="52">bp</name><op:operator pos:line="1010" pos:column="54">++</op:operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
			<if pos:line="1011" pos:column="25">if <condition pos:line="1011" pos:column="28">(<expr><name pos:line="1011" pos:column="29">bp</name> <op:operator pos:line="1011" pos:column="32">&lt;</op:operator> <name pos:line="1011" pos:column="34">ep</name></expr>)</condition><then pos:line="1011" pos:column="37">
				<return pos:line="1012" pos:column="33">return <expr><lit:literal type="number" pos:line="1012" pos:column="40">0</lit:literal></expr>;</return></then></if>
		}</block></then></if>
	}</block></while>
	<expr_stmt><expr><op:operator pos:line="1015" pos:column="9">*</op:operator><name pos:line="1015" pos:column="10">dst</name> <op:operator pos:line="1015" pos:column="14">=</op:operator> <lit:literal type="char" pos:line="1015" pos:column="16">'\0'</lit:literal></expr>;</expr_stmt>
	<return pos:line="1016" pos:column="9">return <expr><lit:literal type="number" pos:line="1016" pos:column="16">1</lit:literal></expr>;</return>
}</block></function>

</unit>
